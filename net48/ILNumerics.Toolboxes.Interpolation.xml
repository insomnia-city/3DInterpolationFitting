<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics.Toolboxes.Interpolation</name>
    </assembly>
    <members>
        <member name="T:ILNumerics.Toolboxes.InterpolationMethod">
            <summary>
            Available methods for interpolation of gridded data
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.linear">
            <summary>
            Linear interpolation
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.cubic">
            <summary>
            Polynomial interpolation, order 3 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.spline">
            <summary>
            Spline interpolation
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.pp">
            <summary>
            Piecewise polynomial interpolation, arbitrary order
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial">
            <summary>
            Polynomial interpolation, order n (global interpolation)
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.nearest">
            <summary>
            Nearest neighbour interpolation
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.previous">
            <summary>
            Previous neighbor interpolation
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.next">
            <summary>
            Next neighbor interpolation
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic">
            <summary>
            Polynomial interpolation, order 2
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X"/>. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method"/> at specified query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and double precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<double> X = linspace</*!HC:inArr1*/double>(-pi, pi, 10);
            Array<double> V = sin(x);
            
            //define query points
            Array<double> Xn = linspace</*!HC:inArr1*/double>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<double> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or interpolations using refinement factor
            Array<double> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or just linear interpolation 
            Array<double> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> for <paramref name="X"/>.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> and <paramref name="V"/> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn"/>, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and double precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            <para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> marks any resulting values with <see cref="F:System.Double.NaN"/> 
            which are laying outside of the domain of <paramref name="V"/>, as specified by <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to control the handling of those values.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<double> X = linspace</*!HC:inArr1*/double>(-pi, pi, 10);
            Array<double> V = sin(x);
            
            //define query points
            Array<double> Xn = linspace</*!HC:inArr1*/double>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<double> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or interpolations using refinement factor
            Array<double> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or just linear interpolation 
            Array<double> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>      
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X"/> and <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X"/>. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method"/> at specified query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and complex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<complex> X = linspace<complex>(-pi, pi, 10);
            Array<complex> V = sin(x);
            
            //define query points
            Array<complex> Xn = linspace<complex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<complex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or interpolations using refinement factor
            Array<complex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or just linear interpolation 
            Array<complex> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> for <paramref name="X"/>.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> and <paramref name="V"/> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn"/>, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and complex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            <para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> marks any resulting values with <see cref="P:ILNumerics.complex.NaN"/> 
            which are laying outside of the domain of <paramref name="V"/>, as specified by <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to control the handling of those values.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<complex> X = linspace<complex>(-pi, pi, 10);
            Array<complex> V = sin(x);
            
            //define query points
            Array<complex> Xn = linspace<complex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<complex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or interpolations using refinement factor
            Array<complex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or just linear interpolation 
            Array<complex> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>      
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X"/> and <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X"/>. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method"/> at specified query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and fcomplex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
            Array<fcomplex> V = sin(x);
            
            //define query points
            Array<fcomplex> Xn = linspace<fcomplex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<fcomplex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or interpolations using refinement factor
            Array<fcomplex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or just linear interpolation 
            Array<fcomplex> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> for <paramref name="X"/>.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> and <paramref name="V"/> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn"/>, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and fcomplex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            <para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> marks any resulting values with <see cref="P:ILNumerics.fcomplex.NaN"/> 
            which are laying outside of the domain of <paramref name="V"/>, as specified by <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to control the handling of those values.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
            Array<fcomplex> V = sin(x);
            
            //define query points
            Array<fcomplex> Xn = linspace<fcomplex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<fcomplex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or interpolations using refinement factor
            Array<fcomplex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or just linear interpolation 
            Array<fcomplex> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>      
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X"/> and <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X"/>. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method"/> at specified query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and float precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<float> X = linspace<float>(-pi, pi, 10);
            Array<float> V = sin(x);
            
            //define query points
            Array<float> Xn = linspace<float>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<float> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or interpolations using refinement factor
            Array<float> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or just linear interpolation 
            Array<float> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> for <paramref name="X"/>.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> and <paramref name="V"/> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V"/>; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k"/>.</param>        
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn"/> is null create new query points by splitting <paramref name="X"/> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn"/>, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> performs one dimensional 
            interpolation, i.e.: interpolation based on sample values <paramref name="V"/> of one variable <paramref name="X"/> at new query points <paramref name="Xn"/>.</para>
            <para>The array <paramref name="V"/> contains the set of known sample values. If <paramref name="V"/> is a vector a vector with the same orientation and length 
            <c>m</c> is returned. If <paramref name="V"/> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V"/>.</para>
            <para><paramref name="X"/> defines the positions for the sample values along the columns in <paramref name="V"/> as a vector of <i>strictly monotonically increasing</i> values. 
            If <paramref name="X"/> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V"/>.</para>
            <para>The parameter <paramref name="Xn"/> holds the vector of positions for the new query points. If <paramref name="Xn"/> is ommitted query point positions  
            are auto-created by splitting the ranges defined by <paramref name="X"/> into half <paramref name="k"/> times.</para>
            The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
            is closest to a new query point. This method needs little computing ressources.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples 
            are required for <paramref name="V"/>. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples are required in <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation for large datasets with less strict smoothness requirements. 
            At least 3 respectively 4 points are required in <paramref name="V"/> for 'parabolic' and 'cubic' polynomials.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation. 
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V"/>. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> or the 
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)"/> interpolation object and specify the order explicitely.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first and <i>second</i> derivatives. At least 3 sample points are required for 
            <paramref name="V"/>. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>, 
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/> 
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its 
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item>
            </list>
            <para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V"/>, including empty arrays and row vectors.
            All, single and float precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for 
            multicore systems and optimized for efficient, cache aware computations on large data.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V"/>.</para>
            <para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> marks any resulting values with <see cref="F:System.Single.NaN"/> 
            which are laying outside of the domain of <paramref name="V"/>, as specified by <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to control the handling of those values.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            //Define any 1-D function
            Array<float> X = linspace<float>(-pi, pi, 10);
            Array<float> V = sin(x);
            
            //define query points
            Array<float> Xn = linspace<float>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<float> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or interpolations using refinement factor
            Array<float> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or just linear interpolation 
            Array<float> Vn = Interpolation.interp1(V);
            ]]>
            </code>
            </para>
            </example>      
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X"/> and <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1"/> and <paramref name="X2"/>. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<double> X2 = 1;
            Array<double> X1 = meshgrid(linspace<double>(-2, 2, 20), linspace<double>(-2, 2, 20), X2);
            Array<double> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<double> Xn2 = 1;
            Array<double> Xn1 = meshgrid(linspace<double>(-3, 3, 50), linspace<double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or spline interpolate using refinement factor
            Array<double> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<double> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/> and <paramref name="X2"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<double> X2 = 1;
            Array<double> X1 = meshgrid(linspace<Double>(-2, 2, 20), linspace<Double>(-2, 2, 20), X2);
            Array<double> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<double> Xn2 = 1;
            Array<double> Xn1 = meshgrid(linspace<Double>(-3, 3, 50), linspace<Double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or spline interpolate using refinement factor
            Array<double> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<double> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1"/> and <paramref name="X2"/>. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<complex> X2 = 1;
            Array<complex> X1 = meshgrid(linspace<complex>(-2, 2, 20), linspace<complex>(-2, 2, 20), X2);
            Array<complex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<complex> Xn2 = 1;
            Array<complex> Xn1 = meshgrid(linspace<complex>(-3, 3, 50), linspace<complex>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or spline interpolate using refinement factor
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<complex> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="!:interp2(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="!:interp2(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/> and <paramref name="X2"/>. Use the overload <see cref="!:interp2(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<complex> X2 = 1;
            Array<complex> X1 = meshgrid(linspace<double>(-2, 2, 20), linspace<double>(-2, 2, 20), X2);
            Array<complex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<complex> Xn2 = 1;
            Array<complex> Xn1 = meshgrid(linspace<double>(-3, 3, 50), linspace<double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or spline interpolate using refinement factor
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<complex> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1"/> and <paramref name="X2"/>. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<fcomplex> X2 = 1;
            Array<fcomplex> X1 = meshgrid(linspace<fcomplex>(-2, 2, 20), linspace<fcomplex>(-2, 2, 20), X2);
            Array<fcomplex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<fcomplex> Xn2 = 1;
            Array<fcomplex> Xn1 = meshgrid(linspace<fcomplex>(-3, 3, 50), linspace<fcomplex>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolate using refinement factor
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<fcomplex> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="!:interp2(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="!:interp2(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/> and <paramref name="X2"/>. Use the overload <see cref="!:interp2(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<fcomplex> X2 = 1;
            Array<fcomplex> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<fcomplex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<fcomplex> Xn2 = 1;
            Array<fcomplex> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolate using refinement factor
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<fcomplex> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1"/> and <paramref name="X2"/>. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<float> X2 = 1;
            Array<float> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<float> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<float> Xn2 = 1;
            Array<float> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or spline interpolate using refinement factor
            Array<float> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<float> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data. 
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/> and/or <paramref name="X2"/> are split 
            <paramref name="k"/> times. Ignored for <paramref name="Xn1"/> or <paramref name="Xn2"/> being not null respectively. Default: 1.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs two dimensional interpolation over the given data matrix <paramref name="V"/> defined in <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> 
            format. The parameter <paramref name="X1"/> specifies the positions of the grid points in <paramref name="V"/> along the first dimension (along the rows of V). 
            <paramref name="X2"/> determines the positions along the 2nd dimension (along the columns of <paramref name="V"/>). Hence, <paramref name="V"/> forms a regular, 
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V"/>: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i> 
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            as an alternative.</para>
            <para>Values in <paramref name="X1"/> and <paramref name="X2"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/> and/or <paramref name="X2"/> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para>
            <para>Values in <paramref name="Xn1"/> and <paramref name="Xn2"/>, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of 
            <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1"/> and/or <paramref name="X2"/> 
            respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/> and <paramref name="X2"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para>
            </remarks>
            
            <example>
            <para>
            <code>
            <![CDATA[
            
            //generate any meshgrid
            Array<float> X2 = 1;
            Array<float> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<float> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<float> Xn2 = 1;
            Array<float> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or spline interpolate using refinement factor
            Array<float> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<float> Vq = Interpolation.interp2(V);
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is set as global polynomial for more than 9 sample points <paramref name="X1"/> or <paramref name="X2"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1"/> or <paramref name="X2"/> do not match the size of <paramref name="V"/>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<double> Y = 1.0f;
             Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
             Array<double> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<Double> Xn = 2 * rand(3000, 1) - 1;
             Array<Double> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: double.NaN);
             
             //or spline interpolation without range definition
             Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<double> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not strictly monotonically increasing.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<double> Y = 1.0f;
             Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
             Array<double> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<Double> Xn = 2 * rand(3000, 1) - 1;
             Array<Double> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: double.NaN);
             
             //or spline interpolation without range definition
             Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<double> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<complex> Y = 1.0f;
             Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
             Array<complex> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<double> Xn = 2 * rand(3000, 1) - 1;
             Array<double> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: complex.NaN);
             
             //or spline interpolation without range definition
             Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<complex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not strictly monotonically increasing.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="!:interp2s(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<complex> Y = 1.0f;
             Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
             Array<complex> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<double> Xn = 2 * rand(3000, 1) - 1;
             Array<double> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: complex.NaN);
             
             //or spline interpolation without range definition
             Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<complex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<fcomplex> Y = 1.0f;
             Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: fcomplex.NaN);
             
             //or spline interpolation without range definition
             Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<fcomplex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not strictly monotonically increasing.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="!:interp2s(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<fcomplex> Y = 1.0f;
             Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: fcomplex.NaN);
             
             //or spline interpolation without range definition
             Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<fcomplex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<float> Y = 1.0f;
             Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<float> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: float.NaN);
             
             //or spline interpolation without range definition
             Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<float> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not strictly monotonically increasing.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and/or <paramref name="Xn2"/> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>2</sup>. 
             </summary>
             <param name="V">Known values, specified as matrix in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> performs interpolation 
             of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension, 
             new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1"/> and <paramref name="Xn2"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. None of <paramref name="Xn1"/> and <paramref name="Xn2"/> 
             can be null. </para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified in <paramref name="X1"/> for the rows in <paramref name="V"/> and <paramref name="X2"/> for
             the columns in <paramref name="V"/>. Any dimension specified as <c>null</c> in <paramref name="X1"/> or <paramref name="X2"/> are considered as auto-ranged with values 
             from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1"/> and <paramref name="X2"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1"/> and <paramref name="Xn2"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<float> Y = 1.0f;
             Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<float> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: float.NaN);
             
             //or spline interpolation without range definition
             Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<float> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data. 
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V"/> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V"/> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V"/> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1"/>,<paramref name="X2"/> and/or <paramref name="X3"/> are split 
            <paramref name="k"/> times. Ignored for any of <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being not null.</param>        
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            performs three dimensional interpolation over the given data array <paramref name="V"/>. The parameter <paramref name="X1"/> specifies the 
            positions of the grid points in <paramref name="V"/> along the first dimension (the columns of V). <paramref name="X2"/> determines the positions along the 
            2nd dimension (rows of <paramref name="V"/>) and so forth. Hence, <paramref name="V"/> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para>
            <para>Values in <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1: 
            0:1:m, where m = size(V, d).</para>
            <para>Values in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>, if provided, must be strictly monotonically increasing but not necessarily have 
            uniform spacing. If any of <paramref name="Xn1"/>, <paramref name="Xn2"/> and/or <paramref name="Xn3"/> are ommitted, default query grid positions are assumed by subdividing 
            <paramref name="X1"/>, <paramref name="X2"/> and/or <paramref name="X3"/> respectively, '<paramref name="k"/>' times.</para>
            <para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            for a detailed description.</para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X1"/>, <paramref name="X2"/> and <paramref name="X3"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X"/>.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;double>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'Double' since this gives both: best performance and best precision. Other element types are converted to 
            double arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>If <paramref name="outOfRangeValues"/> is given as <c>null</c> affected elements will be extrapolated from the existing sample points 
            according to <paramref name="method"/>. Otherwise, the value given in <paramref name="outOfRangeValues"/> is assigned to these query points.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X"/>. Use the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any cell element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;double>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'Double' since it gives both: best performance and best precision. Other element types are converted to 
            Double arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns NaN to all query points laying outside 
            of the range as specified in <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X"/>.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;complex>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'double' since this gives both: best performance and best precision. Other element types are converted to 
            complex arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>If <paramref name="outOfRangeValues"/> is given as <c>null</c> affected elements will be extrapolated from the existing sample points 
            according to <paramref name="method"/>. Otherwise, the value given in <paramref name="outOfRangeValues"/> is assigned to these query points.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X"/>. Use the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any cell element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;complex>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'double' since it gives both: best performance and best precision. Other element types are converted to 
            double arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns NaN to all query points laying outside 
            of the range as specified in <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X"/>.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;fcomplex>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'float' since this gives both: best performance and best precision. Other element types are converted to 
            fcomplex arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>If <paramref name="outOfRangeValues"/> is given as <c>null</c> affected elements will be extrapolated from the existing sample points 
            according to <paramref name="method"/>. Otherwise, the value given in <paramref name="outOfRangeValues"/> is assigned to these query points.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X"/>. Use the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any cell element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;fcomplex>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'float' since it gives both: best performance and best precision. Other element types are converted to 
            float arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns NaN to all query points laying outside 
            of the range as specified in <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X"/>.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;float>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'float' since this gives both: best performance and best precision. Other element types are converted to 
            float arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>If <paramref name="outOfRangeValues"/> is given as <c>null</c> affected elements will be extrapolated from the existing sample points 
            according to <paramref name="method"/>. Otherwise, the value given in <paramref name="outOfRangeValues"/> is assigned to these query points.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V"/>. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn"/>.</returns>
            <remarks>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> interpolates new points from a rectilinear, 
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V"/> as well as the set of new query points <paramref name="Xn"/> 
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However, 
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para>
            <para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns 
            NaN to all query points laying outside of the range of <paramref name="X"/>. Use the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para>
            <para>As a special case <paramref name="V"/> can be a row vector or a column vector. In this case <paramref name="X"/> and <paramref name="Xn"/> 
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V"/>.</para>
            <para>In the general case <paramref name="X"/> and <paramref name="Xn"/> are cell containers, each holding N vectors of range definitions. 
            <paramref name="X"/> describes the 'coordinates' for the N dimensions of <paramref name="V"/>. <paramref name="Xn"/> specifies the grid of new query points 
            to be interpolated. Here, <paramref name="Xn"/> determines a hyper cube of N dimensions. Each array from <paramref name="Xn"/> corresponds 
            to one dimension of the resulting N-dim array.</para>
            <para>Cell array elements in both, <paramref name="X"/> and <paramref name="Xn"/> must be arrays with strictly monotonically increasing numerical elements. They form a 
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in 
            <paramref name="X"/> and <paramref name="Xn"/> can be arbitrary.</para>
            <para>Any cell element specified in <paramref name="X"/> for a specific dimension <c>i</c> must match the length of the corresponding 
            dimension in <paramref name="V"/>, i.e. <code>X.GetArray&lt;float>(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X"/> 
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V"/> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>. 
            If <paramref name="Xn"/> equals <c>null</c> all dimensions in <paramref name="V"/> are auto generated.</para>
            <para>Cell elements in <paramref name="X"/> and <paramref name="Xn"/> may have any numeric element type. However, it is recommended to provide these ranges 
            as <see cref="T:ILNumerics.Array`1"/> of element type 'float' since it gives both: best performance and best precision. Other element types are converted to 
            float arrays internally.</para>
            <para>The <paramref name="method"/> parameter determines the algorithm used for interpolation. The default method is 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/>. The following methods are supported: 
            <list type="bullet">
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the nearest sample point in terms of its 
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means 
            in relation to your hardware).</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point from the surrounding hyper cube with the smallest index 
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned. 
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from the surrounding hyper cube with the highest index in each 
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned. 
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/> - Linear interpolation between adjacent sample points, produces continous function values 
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample 
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of 
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>. 
            At least two samples in each dimension are needed in each working dimension of <paramref name="V"/> for linear interpolation.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp"/> - 
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point. 
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives 
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> interpolation is able to serve as a quick alternative 
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> interpolation. 
            At least 3 or 4 points are required in <paramref name="V"/> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately. 
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of 
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V. 
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/>.</item>
            <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline"/> - cubic spline interpolation produces the smoothest results in terms of function values as well 
            as its first <i>and</i> second derivatives. For uniform <paramref name="V"/> (i.e. elements of X are equally spaced within each dimension but not 
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges 
            of <paramref name="V"/> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform 
            <paramref name="X"/> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for 
            <paramref name="V"/> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> directly if more 
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher 
            computational demands.</item>
            </list></para>
            <para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> assigns NaN to all query points laying outside 
            of the range as specified in <paramref name="X"/>. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed function value outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<double> Y = 1.0f;
             Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
             Array<double> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<Double> Xn = 2 * rand(3000, 1) - 1;
             Array<Double> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: double.NaN);
             
             //or spline interpolation without range definition
             Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<double> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not ascending and distinct specified.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<double> Y = 1.0f;
             Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
             Array<double> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<Double> Xn = 2 * rand(3000, 1) - 1;
             Array<Double> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: double.NaN);
             
             //or spline interpolation without range definition
             Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<double> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported. By default, linear interpolation is performed.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed function value outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="!:interp3s(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<complex> Y = 1.0f;
             Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
             Array<complex> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<double> Xn = 2 * rand(3000, 1) - 1;
             Array<double> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: complex.NaN);
             
             //or spline interpolation without range definition
             Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<complex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not ascending and distinct specified.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="!:interp3s(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<complex> Y = 1.0f;
             Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
             Array<complex> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<double> Xn = 2 * rand(3000, 1) - 1;
             Array<double> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: complex.NaN);
             
             //or spline interpolation without range definition
             Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<complex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported. By default, linear interpolation is performed.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed function value outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="!:interp3s(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<fcomplex> Y = 1.0f;
             Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: fcomplex.NaN);
             
             //or spline interpolation without range definition
             Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<fcomplex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not ascending and distinct specified.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="!:interp3s(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<fcomplex> Y = 1.0f;
             Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: fcomplex.NaN);
             
             //or spline interpolation without range definition
             Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<fcomplex> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported. By default, linear interpolation is performed.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <param name="outOfRangeValues">Fixed function value outside of the domain of <paramref name="V"/> or <c>null</c> for extrapolation.</param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
             the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
             element in <paramref name="V"/>.</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate a meshgrid [-1:1]
             Array<float> Y = 1.0f;
             Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<float> V = sqrt(1 - X * X - Y * Y);
            
             //define random scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Linear interpolation 
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: float.NaN);
             
             //or spline interpolation without range definition
             Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls return an empty array, because query points not set
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<float> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is <c>null</c>.</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are not ascending and distinct specified.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>
             Interpolate scattered query points from gridded sample data in R<sup>3</sup>. 
             </summary>
             <param name="V">Known values, specified as 3D array in meshgrid format.</param>
             <param name="X1">Sample positions of grid points along the rows of <paramref name="V"/>, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
             <param name="X2">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="X3">Sample positions of grid points along the columns of <paramref name="V"/>, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
             <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
             <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
             <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
             <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
             <returns>Interpolated values at query points given in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>.</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
             performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with 
             uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation 
             are specified dimension-wise in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/>. 
             Therefore, the number of elements in <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> must match. <paramref name="Xn1"/> specifies the coordinates in the first 
             dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V"/>. <paramref name="Xn2"/> specifies the coordinates in the 
             second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V"/>. <paramref name="Xn3"/> defines the Z coordinates. 
             None of <paramref name="Xn1"/>, <paramref name="Xn2"/> and <paramref name="Xn3"/> can be null.</para>
             <para>The positions of the grid elements in <paramref name="V"/> are specified as grid vectors in <paramref name="X1"/> for the rows in <paramref name="V"/> and 
             <paramref name="X2"/>/ <paramref name="X3"/> for the columns / 3rd dimension in <paramref name="V"/>. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1"/>.. <paramref name="X3"/> 
             are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1"/> ... <paramref name="X3"/> must be arrays with 
             strictly monotonically increasing elements.</para>
             <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
             <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
             <para>Any elements in <paramref name="Xn1"/> or <paramref name="Xn2"/> or <paramref name="Xn3"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
             <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
             <para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1"/> ... <paramref name="Xn3"/>.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             //generate any meshgrid [-1:1]
             Array<float> Y = 1.0f;
             Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
             Array<float> V = sqrt(1 - X * X - Y * Y);
            
             //define random generated scattered points [-1:1]
             Array<float> Xn = 2 * rand(3000, 1) - 1;
             Array<float> Yn = 2 * rand(3000, 1) - 1;
             
             //Interpolate
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: float.NaN);
             
             //or spline interpolation without range definition
             Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
             
             //this two function calls returns an empty array, because query points not set
             Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
             //or 
             Array<float> Vq = Interpolation.interp2s(V);
             
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V"/> is NULL</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X1"/> or <paramref name="X2"/> are found to be not strictly monotonically ascending.</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1"/> and <paramref name="Xn2"/> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary> 
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V"/>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial"/> and 
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic"/>. By default, linear interpolation is performed.</para>
            <para><paramref name="V"/> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para>
            <para>Any elements in <paramref name="Xn"/> being NaN will cause the corresponding interpolation result to be considered as 'out of range: 
            the value given in <paramref name="outOfRangeValues"/> will be assigned to it. If <paramref name="outOfRangeValues"/> is <c>null</c> those elements are mapped to the first grid 
            element in <paramref name="V"/>.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked with the value provided in <paramref name="outOfRangeValues"/>. Set this value to <c>null</c> 
            in order to achieve extrapolation for those values.</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>. 
            </summary>       
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V"/>, specified as cell array elements for each dimension in <paramref name="V"/>.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear"/></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> performs n-dimensional interpolation 
            of individual scattered points on the n-dimensional domain <paramref name="V"/>. While V corresponds to a rectilinear grid with uniform or non-uniform ranges 
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are 
            specified dimension-wise in the individual cell elements of <paramref name="Xn"/>. Therefore, all such cells elements must be not <c>null</c> and have all 
            the same number of elements.</para>
            <para>The positions of the grid elements in <paramref name="V"/> are specified by <paramref name="X"/> for the individual dimensions in <paramref name="V"/>. 
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X"/> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise, 
            all arrays provided in <paramref name="X"/> must have strictly monotonically increasing elements.</para>
            <para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod"/> is supported. By default, linear interpolation is performed.</para>
            <para>Any elements outside of the domain of <paramref name="V"/> are marked as NaN (not a number).</para>
            <para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn"/>, i.e. the number of query points.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.kriging(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.OutArray{System.Double})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X"/>. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X"/> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn"/></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation. 
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X"/>. The algorithm will remove any points 
            being too close to each in order to increase stability of the algorithm.</para>
            <para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para>
            <para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="V"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.kriging(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.OutArray{System.Double})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X"/>. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X"/> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn"/></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation. 
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X"/>. The algorithm will remove any points 
            being too close to each in order to increase stability of the algorithm.</para>
            <para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para>
            <para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="V"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.kriging(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.OutArray{System.Single})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X"/>. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X"/> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn"/></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation. 
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X"/>. The algorithm will remove any points 
            being too close to each in order to increase stability of the algorithm.</para>
            <para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para>
            <para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="V"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.kriging(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.OutArray{System.Single})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X"/>. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X"/> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn"/></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation. 
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X"/>. The algorithm will remove any points 
            being too close to each in order to increase stability of the algorithm.</para>
            <para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para>
            <para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="V"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. However, all dimensions of the 
            original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> is not provided 
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> control the derivatives at the lower bound and at the upper bound of the sampled domain. The 
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next 
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para>
            <para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/>.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object 
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object 
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V"/> is required.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. 
            However, all dimensions of the original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> 
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter 
            ('outOfRangeValues') from the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> 
            in order to control this value or to get extrapolated values instead.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/> function serves as a wrapper for 
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information 
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object directly if optimal performance for multiple interpolations based 
            on the same dataset <paramref name="V"/> is required.</para>
            <para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V"/>.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)">
             <summary>
             Create interpolated values for the path through points given by <paramref name="X"/> in R^n. 
             </summary>
             <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
             <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution"/>] times as many intermediate points as given in <paramref name="X"/>.</param>
             <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
             <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
             <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X"/>. Default is 20.</param>
             <returns>Matrix with smoothed path through points defined by <paramref name="X"/>. Number of rows: X.S[0], number of columns: Xn.Length</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/> creates a smooth path connecting the points 
             defined by the columns of <paramref name="X"/>. Cubic spline interpolation is used to create intermediate points within individual seqments between the original 
             points. The matrix returned can be directly used for rendering purposes.</para>
             <para><paramref name="X"/> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X"/> 
             defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para>
             <para>The parameter <paramref name="Xn"/> allows to control the number and position of intermediate points. The function expects a vector with 
             values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X"/>). 1 corresponds to the end of 
             the path at the last point in <paramref name="X"/>. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn"/> is 
             null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values 
             are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X"/>.</para>
             <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> are used to specify the 1st order derivative at the lower and 
             upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end 
             point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv"/> and/or <paramref name="ubDeriv"/> the corresponding 
             end of the path will be computed as having that value as <i>first derivative</i> (slope).</para>
             <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
             <paramref name="X"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X"/>
             populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
             for an alternative on data with NaN values.</para>
             </remarks>
             <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para>
             <code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
                // create 21 random points in 3d space
                Array</*!HC:inArr1*/ double> Points = rand(3, 21); 
            
                // setup the plot cube ... 
                ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
                    // ... render original points as markers (line color: "empty" hides the line of the line plot)
                    new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
                });
            
                // setup labels next to the points
                for (int i = 0; i < Points.S[1]; i++) {
                    // position for the label 
                    Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i)); 
                    // add new label 
                    ilPanel1.Scene.First<PlotCube>().Add(
                        new Label(i.ToString() + " ") { 
                            Position = pos,  
                            // create some margin 
                            Anchor = new PointF(1.5f,.5f)
                        });
                }
                // generate spline interpolated values for a smoothed path through the points
                Array</*!HC:inArr1*/ double> spl = spline(Points);
                // draw the path as regular line plot
                ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl))); 
            }
            ]]></code></example>
             <seealso cref="T:ILNumerics.Toolboxes.Interpolation"/>
             <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. However, all dimensions of the 
            original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> is not provided 
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> control the derivatives at the lower bound and at the upper bound of the sampled domain. The 
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next 
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para>
            <para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object 
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object 
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V"/> is required.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. 
            However, all dimensions of the original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> 
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter 
            ('outOfRangeValues') from the overload <see cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/> 
            in order to control this value or to get extrapolated values instead.</para>
            <para>The <see cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/> function serves as a wrapper for 
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information 
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object directly if optimal performance for multiple interpolations based 
            on the same dataset <paramref name="V"/> is required.</para>
            <para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V"/>.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/>
            <seealso cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)">
             <summary>
             Create interpolated values for the path through points given by <paramref name="X"/> in R^n. 
             </summary>
             <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
             <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution"/>] times as many intermediate points as given in <paramref name="X"/>.</param>
             <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
             <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
             <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X"/>. Default is 20.</param>
             <returns>Matrix with smoothed path through points defined by <paramref name="X"/>. Number of rows: X.S[0], number of columns: Xn.Length</returns>
             <remarks><para><see cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/> creates a smooth path connecting the points 
             defined by the columns of <paramref name="X"/>. Cubic spline interpolation is used to create intermediate points within individual seqments between the original 
             points. The matrix returned can be directly used for rendering purposes.</para>
             <para><paramref name="X"/> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X"/> 
             defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para>
             <para>The parameter <paramref name="Xn"/> allows to control the number and position of intermediate points. The function expects a vector with 
             values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X"/>). 1 corresponds to the end of 
             the path at the last point in <paramref name="X"/>. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn"/> is 
             null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values 
             are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X"/>.</para>
             <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> are used to specify the 1st order derivative at the lower and 
             upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end 
             point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv"/> and/or <paramref name="ubDeriv"/> the corresponding 
             end of the path will be computed as having that value as <i>first derivative</i> (slope).</para>
             <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
             <paramref name="X"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X"/>
             populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
             for an alternative on data with NaN values.</para>
             </remarks>
             <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para>
             <code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
                // create 21 random points in 3d space
                Array< complex> Points = rand(3, 21); 
            
                // setup the plot cube ... 
                ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
                    // ... render original points as markers (line color: "empty" hides the line of the line plot)
                    new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
                });
            
                // setup labels next to the points
                for (int i = 0; i < Points.S[1]; i++) {
                    // position for the label 
                    Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i)); 
                    // add new label 
                    ilPanel1.Scene.First<PlotCube>().Add(
                        new Label(i.ToString() + " ") { 
                            Position = pos,  
                            // create some margin 
                            Anchor = new PointF(1.5f,.5f)
                        });
                }
                // generate spline interpolated values for a smoothed path through the points
                Array< complex> spl = spline(Points);
                // draw the path as regular line plot
                ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl))); 
            }
            ]]></code></example>
             <seealso cref="T:ILNumerics.Toolboxes.Interpolation"/>
             <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
             <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
             <seealso cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. However, all dimensions of the 
            original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> is not provided 
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> control the derivatives at the lower bound and at the upper bound of the sampled domain. The 
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next 
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para>
            <para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/>.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object 
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object 
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V"/> is required.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. 
            However, all dimensions of the original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> 
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter 
            ('outOfRangeValues') from the overload <see cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/> 
            in order to control this value or to get extrapolated values instead.</para>
            <para>The <see cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/> function serves as a wrapper for 
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information 
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object directly if optimal performance for multiple interpolations based 
            on the same dataset <paramref name="V"/> is required.</para>
            <para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V"/>.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/>
            <seealso cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)">
             <summary>
             Create interpolated values for the path through points given by <paramref name="X"/> in R^n. 
             </summary>
             <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
             <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution"/>] times as many intermediate points as given in <paramref name="X"/>.</param>
             <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
             <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
             <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X"/>. Default is 20.</param>
             <returns>Matrix with smoothed path through points defined by <paramref name="X"/>. Number of rows: X.S[0], number of columns: Xn.Length</returns>
             <remarks><para><see cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/> creates a smooth path connecting the points 
             defined by the columns of <paramref name="X"/>. Cubic spline interpolation is used to create intermediate points within individual seqments between the original 
             points. The matrix returned can be directly used for rendering purposes.</para>
             <para><paramref name="X"/> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X"/> 
             defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para>
             <para>The parameter <paramref name="Xn"/> allows to control the number and position of intermediate points. The function expects a vector with 
             values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X"/>). 1 corresponds to the end of 
             the path at the last point in <paramref name="X"/>. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn"/> is 
             null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values 
             are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X"/>.</para>
             <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> are used to specify the 1st order derivative at the lower and 
             upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end 
             point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv"/> and/or <paramref name="ubDeriv"/> the corresponding 
             end of the path will be computed as having that value as <i>first derivative</i> (slope).</para>
             <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
             <paramref name="X"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X"/>
             populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
             for an alternative on data with NaN values.</para>
             </remarks>
             <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para>
             <code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
                // create 21 random points in 3d space
                Array< fcomplex> Points = rand(3, 21); 
            
                // setup the plot cube ... 
                ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
                    // ... render original points as markers (line color: "empty" hides the line of the line plot)
                    new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
                });
            
                // setup labels next to the points
                for (int i = 0; i < Points.S[1]; i++) {
                    // position for the label 
                    Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i)); 
                    // add new label 
                    ilPanel1.Scene.First<PlotCube>().Add(
                        new Label(i.ToString() + " ") { 
                            Position = pos,  
                            // create some margin 
                            Anchor = new PointF(1.5f,.5f)
                        });
                }
                // generate spline interpolated values for a smoothed path through the points
                Array< fcomplex> spl = spline(Points);
                // draw the path as regular line plot
                ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl))); 
            }
            ]]></code></example>
             <seealso cref="T:ILNumerics.Toolboxes.Interpolation"/>
             <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/>
             <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
             <seealso cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. However, all dimensions of the 
            original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> is not provided 
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> control the derivatives at the lower bound and at the upper bound of the sampled domain. The 
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next 
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para>
            <para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/>.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object 
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object 
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V"/> is required.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V"/>. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V"/>.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X"/> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V"/> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para>
            <para><paramref name="V"/> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V"/> = V[":;:"]. 
            However, all dimensions of the original <paramref name="V"/> are retained and considered for the return value (shape preserving).</para>
            <para>While the rows of <paramref name="V"/> hold the ensemble of measurements for each sample position, <paramref name="X"/> holds the coordinates of these positions. If 
            <paramref name="X"/> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X"/> 
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter 
            ('outOfRangeValues') from the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/> 
            in order to control this value or to get extrapolated values instead.</para>
            <para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/> function serves as a wrapper for 
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information 
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object directly if optimal performance for multiple interpolations based 
            on the same dataset <paramref name="V"/> is required.</para>
            <para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V"/>.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            </remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)">
             <summary>
             Create interpolated values for the path through points given by <paramref name="X"/> in R^n. 
             </summary>
             <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
             <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution"/>] times as many intermediate points as given in <paramref name="X"/>.</param>
             <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
             <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
             <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X"/>. Default is 20.</param>
             <returns>Matrix with smoothed path through points defined by <paramref name="X"/>. Number of rows: X.S[0], number of columns: Xn.Length</returns>
             <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/> creates a smooth path connecting the points 
             defined by the columns of <paramref name="X"/>. Cubic spline interpolation is used to create intermediate points within individual seqments between the original 
             points. The matrix returned can be directly used for rendering purposes.</para>
             <para><paramref name="X"/> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X"/> 
             defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para>
             <para>The parameter <paramref name="Xn"/> allows to control the number and position of intermediate points. The function expects a vector with 
             values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X"/>). 1 corresponds to the end of 
             the path at the last point in <paramref name="X"/>. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn"/> is 
             null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values 
             are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X"/>.</para>
             <para>The parameters <paramref name="lbDeriv"/> and <paramref name="ubDeriv"/> are used to specify the 1st order derivative at the lower and 
             upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end 
             point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv"/> and/or <paramref name="ubDeriv"/> the corresponding 
             end of the path will be computed as having that value as <i>first derivative</i> (slope).</para>
             <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
             <paramref name="X"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X"/>
             populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
             for an alternative on data with NaN values.</para>
             </remarks>
             <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para>
             <code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
                // create 21 random points in 3d space
                Array< float> Points = rand(3, 21); 
            
                // setup the plot cube ... 
                ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
                    // ... render original points as markers (line color: "empty" hides the line of the line plot)
                    new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
                });
            
                // setup labels next to the points
                for (int i = 0; i < Points.S[1]; i++) {
                    // position for the label 
                    Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i)); 
                    // add new label 
                    ilPanel1.Scene.First<PlotCube>().Add(
                        new Label(i.ToString() + " ") { 
                            Position = pos,  
                            // create some margin 
                            Anchor = new PointF(1.5f,.5f)
                        });
                }
                // generate spline interpolated values for a smoothed path through the points
                Array< float> spl = spline(Points);
                // draw the path as regular line plot
                ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl))); 
            }
            ]]></code></example>
             <seealso cref="T:ILNumerics.Toolboxes.Interpolation"/>
             <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
             <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids. 
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X"/>). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1"/> corresponding to element type of <paramref name="V"/>) with the <i>strictly monotonically increasing</i> range specification 
            for the corresponding dimension in <paramref name="V"/>. The spacing between elements within each dimension must not be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="Xn"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual 
            arrays in the cell <paramref name="Xn"/> form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, 
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for the corresponding dimension in <paramref name="V"/>, 
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X"/>. Every grid cell determined 
            by <paramref name="X"/> is therefore split into half, roughly doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>.</para>
            <para>Algorithm for uniform <paramref name="V"/>: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> for uniform data <paramref name="V"/> (as specified by <paramref name="X"/>)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X"/> to the unit interval [0,1] and applying the new positions to 
            the surrounding two hypercubes in each dimension of <paramref name="V"/>. The algorithm is optimized 
            for large data <paramref name="V"/> and fine <paramref name="Xn"/> grids. Fastest results are obtained when many new query points are to be computed per hypercube 
            in <paramref name="V"/> and if these points are arranged along the first dimension of <paramref name="V"/>. I.e: when a significant large range was provided in <paramref name="Xn"/>[0].</para>
            <para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para>
            <para>On non-uniform data <paramref name="V"/> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>.
            </para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid. 
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of <paramref name="V"/>) with <i>strictly 
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V"/>. The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, the grid of new values is 
            always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for 
            the corresponding dimension in <paramref name="V"/>, the ranges for the new values in the corresponding dimension to be returned are computed by 
            refining the existing range from <paramref name="X"/>. Every grid cell determined by <paramref name="X"/> is therefore split into half, roughly 
            doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> offers.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>. Good performance is achieved via 
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids. 
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X"/>). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1"/> corresponding to element type of <paramref name="V"/>) with the <i>strictly monotonically increasing</i> range specification 
            for the corresponding dimension in <paramref name="V"/>. The spacing between elements within each dimension must not be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="Xn"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual 
            arrays in the cell <paramref name="Xn"/> form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, 
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for the corresponding dimension in <paramref name="V"/>, 
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X"/>. Every grid cell determined 
            by <paramref name="X"/> is therefore split into half, roughly doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>.</para>
            <para>Algorithm for uniform <paramref name="V"/>: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> for uniform data <paramref name="V"/> (as specified by <paramref name="X"/>)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X"/> to the unit interval [0,1] and applying the new positions to 
            the surrounding two hypercubes in each dimension of <paramref name="V"/>. The algorithm is optimized 
            for large data <paramref name="V"/> and fine <paramref name="Xn"/> grids. Fastest results are obtained when many new query points are to be computed per hypercube 
            in <paramref name="V"/> and if these points are arranged along the first dimension of <paramref name="V"/>. I.e: when a significant large range was provided in <paramref name="Xn"/>[0].</para>
            <para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para>
            <para>On non-uniform data <paramref name="V"/> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/>.
            </para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid. 
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of <paramref name="V"/>) with <i>strictly 
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V"/>. The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, the grid of new values is 
            always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for 
            the corresponding dimension in <paramref name="V"/>, the ranges for the new values in the corresponding dimension to be returned are computed by 
            refining the existing range from <paramref name="X"/>. Every grid cell determined by <paramref name="X"/> is therefore split into half, roughly 
            doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> offers.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})"/>. Good performance is achieved via 
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids. 
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X"/>). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1"/> corresponding to element type of <paramref name="V"/>) with the <i>strictly monotonically increasing</i> range specification 
            for the corresponding dimension in <paramref name="V"/>. The spacing between elements within each dimension must not be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="Xn"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual 
            arrays in the cell <paramref name="Xn"/> form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, 
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for the corresponding dimension in <paramref name="V"/>, 
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X"/>. Every grid cell determined 
            by <paramref name="X"/> is therefore split into half, roughly doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>.</para>
            <para>Algorithm for uniform <paramref name="V"/>: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> for uniform data <paramref name="V"/> (as specified by <paramref name="X"/>)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X"/> to the unit interval [0,1] and applying the new positions to 
            the surrounding two hypercubes in each dimension of <paramref name="V"/>. The algorithm is optimized 
            for large data <paramref name="V"/> and fine <paramref name="Xn"/> grids. Fastest results are obtained when many new query points are to be computed per hypercube 
            in <paramref name="V"/> and if these points are arranged along the first dimension of <paramref name="V"/>. I.e: when a significant large range was provided in <paramref name="Xn"/>[0].</para>
            <para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para>
            <para>On non-uniform data <paramref name="V"/> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/>.
            </para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid. 
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of <paramref name="V"/>) with <i>strictly 
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V"/>. The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, the grid of new values is 
            always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for 
            the corresponding dimension in <paramref name="V"/>, the ranges for the new values in the corresponding dimension to be returned are computed by 
            refining the existing range from <paramref name="X"/>. Every grid cell determined by <paramref name="X"/> is therefore split into half, roughly 
            doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> offers.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})"/>. Good performance is achieved via 
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids. 
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X"/>). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1"/> corresponding to element type of <paramref name="V"/>) with the <i>strictly monotonically increasing</i> range specification 
            for the corresponding dimension in <paramref name="V"/>. The spacing between elements within each dimension must not be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="Xn"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual 
            arrays in the cell <paramref name="Xn"/> form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, 
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for the corresponding dimension in <paramref name="V"/>, 
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X"/>. Every grid cell determined 
            by <paramref name="X"/> is therefore split into half, roughly doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>.</para>
            <para>Algorithm for uniform <paramref name="V"/>: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> for uniform data <paramref name="V"/> (as specified by <paramref name="X"/>)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X"/> to the unit interval [0,1] and applying the new positions to 
            the surrounding two hypercubes in each dimension of <paramref name="V"/>. The algorithm is optimized 
            for large data <paramref name="V"/> and fine <paramref name="Xn"/> grids. Fastest results are obtained when many new query points are to be computed per hypercube 
            in <paramref name="V"/> and if these points are arranged along the first dimension of <paramref name="V"/>. I.e: when a significant large range was provided in <paramref name="Xn"/>[0].</para>
            <para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para>
            <para>On non-uniform data <paramref name="V"/> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>.
            </para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid. 
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V"/>. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X"/> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn"/>.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation on a n-dimensional 
            <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays 
            as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of <paramref name="V"/>) with <i>strictly 
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V"/>. The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            form a grid of the same dimensionality as <paramref name="V"/>. Therefore and similarily to <paramref name="X"/>, the grid of new values is 
            always <i>regular</i> but <i>not</i> necessarily uniform.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>If <paramref name="Xn"/> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn"/> being not provided for 
            the corresponding dimension in <paramref name="V"/>, the ranges for the new values in the corresponding dimension to be returned are computed by 
            refining the existing range from <paramref name="X"/>. Every grid cell determined by <paramref name="X"/> is therefore split into half, roughly 
            doubling the resolution for the resulting range.</para>
            <para>Any of <paramref name="X"/> and <paramref name="Xn"/> inputs are allowed to provide not only vectors but n-dimensional arrays as 
            the result of functions like <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>. 
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> offers.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>. Good performance is achieved via 
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            </remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked with the value given in <paramref name="outofRangeValues"/>. 
            Use <c>null</c> to get extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked as 'NaN' 
            values. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})"/> to control this value or to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked with 
            the value given in <paramref name="outofRangeValues"/>. Use <c>null</c> for <paramref name="outofRangeValues"/> to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked with the value given in <paramref name="outofRangeValues"/>. 
            Use <c>null</c> to get extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked as 'NaN' 
            values. Use the overload <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)"/> to control this value or to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/>
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked with 
            the value given in <paramref name="outofRangeValues"/>. Use <c>null</c> for <paramref name="outofRangeValues"/> to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/>
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked with the value given in <paramref name="outofRangeValues"/>. 
            Use <c>null</c> to get extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked as 'NaN' 
            values. Use the overload <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)"/> to control this value or to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/>
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked with 
            the value given in <paramref name="outofRangeValues"/>. Use <c>null</c> for <paramref name="outofRangeValues"/> to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/>
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked as NaN. Use the 2nd non-optional parameter from the overload 
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})"/> in order to control this value or to get extrapolated values instead.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the grid vectors <paramref name="Xn"/>. Individual arrays in the cell <paramref name="Xn"/> 
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn"/> must expose 
            the same number of elements: <c>m</c>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> are marked with the value given in <paramref name="outofRangeValues"/>. 
            Use <c>null</c> to get extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n 
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on efficiency: for large <paramref name="Xn"/> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})"/> since 
            this will be called anyway. Hence, if your <paramref name="Xn"/> data exists in matrix form, consider using the matching overload instead.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked as 'NaN' 
            values. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})"/> to control this value or to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V"/>. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V"/>. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn"/>. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> performs efficient piecewise cubic interpolation with continous 2nd derivatives 
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V"/>. <paramref name="X"/> is expected as a cell vector with 
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T> corresponding to element type T of 
            <paramref name="V"/>) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V"/>. 
            The spacing between elements must <i>not</i> be uniform.</para>
            <para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> will always match the 
            given data values <paramref name="V"/> at the specified sample positions <paramref name="X"/>.</para>
            <para>New values to be interpolated are specified by the columns in <paramref name="Xn"/>.</para>
            <para>Any range for <paramref name="V"/> not provided in <paramref name="X"/> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by 
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X"/> is null on entry, the 
            same scheme applies to all dimensions of <paramref name="V"/>.</para>
            <para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/> both, <paramref name="X"/> and <paramref name="Xn"/> are obligatory parameters!
            <paramref name="Xn"/> is not allowed to be null on entry.</para>
            <para><paramref name="X"/> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/>
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first 
            cell element in <paramref name="X"/> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V"/>. Note that 
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.ILMath.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})"/> shows.</para>
            <para>Any values from <paramref name="Xn"/> laying <b>outside of the range</b> of <paramref name="X"/> will cause the corresponding result elements to be marked with 
            the value given in <paramref name="outofRangeValues"/>. Use <c>null</c> for <paramref name="outofRangeValues"/> to compute extrapolated values at those positions.</para>
            <para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})"/> performs one-dimensional interpolation of the spline <i>coefficients</i> 
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for 
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> object. However, the interpolation 
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on 
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic"/> 
            instead.</para>
            <para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of 
            <paramref name="V"/> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V"/>
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V"/>. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/> 
            for an alternative on data with NaN values.</para>
            <para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>.</para>
            <para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})"/>.</para>
            <para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para>
            </remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)"/>
            <exception cref="T:System.ArgumentException">if <paramref name="V"/> has less than 4 elements in any dimension or any range in <paramref name="X"/> does 
            not match the corresponding dimension length in <paramref name="V"/>.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V"/> or <paramref name="X"/> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.RedistArray(ILNumerics.InArray{System.Double})">
            <summary>
            Function redistributes array for nearest neighbor interpolation.
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.RefineArray(ILNumerics.InArray{System.Double},System.Int32)">
            <summary>
            Function refines array using refinement factor k. Divides each segment k times
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.RedistArray(ILNumerics.InArray{System.Single})">
            <summary>
            Function redistributes array for nearest neighbor interpolation.
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.RefineArray(ILNumerics.InArray{System.Single},System.Int32)">
            <summary>
            Function refines array using refinement factor k. Divides each segment k times
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.GetPolyCoeff(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)">
            <summary>
             Function calculates coefficients for polynom of <paramref name="k"/> order. Returns n-dimensional array coefficients.
            </summary>
            <param name="X"></param>
            <param name="V"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.GetPolyCoeff(ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},System.Int32)">
            <summary>
             Function calculates coefficients for polynom of <paramref name="k"/> order. Returns n-dimensional array coefficients.
            </summary>
            <param name="X"></param>
            <param name="V"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.GetPolyCoeff(ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
             Function calculates coefficients for polynom of <paramref name="k"/> order. Returns n-dimensional array coefficients.
            </summary>
            <param name="X"></param>
            <param name="V"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.GetPolyCoeff(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)">
            <summary>
             Function calculates coefficients for polynom of <paramref name="k"/> order. Returns n-dimensional array coefficients.
            </summary>
            <param name="X"></param>
            <param name="V"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.InterpolationHelper.compute2adicExtension(System.Int64,ILNumerics.InArray{System.Int64})">
            <summary>
            2-adic extension (used for interpn_linear)
            </summary>
            <param name="n">number of dimensions</param>
            <param name="seqIndices">sequential indices, dimension / size specifier</param>
            <returns>2 adic extension for the dimensions specified by n</returns>
        </member>
        <member name="T:ILNumerics.Toolboxes.Interpolation">
            <summary>
            The Interpolation class provides static functions for the efficient interpolation of 1d, 2d, 3d and n-d gridded and scattered data.  
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X" />. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method" /> at specified query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and double precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<double> X = linspace</*!HC:inArr1*/double>(-pi, pi, 10);
            Array<double> V = sin(x);
            
            //define query points
            Array<double> Xn = linspace</*!HC:inArr1*/double>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<double> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or interpolations using refinement factor
            Array<double> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or just linear interpolation
            Array<double> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> for <paramref name="X" />.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X" /> and <paramref name="V" /> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn" />, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and double precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para><para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> marks any resulting values with <see cref="F:System.Double.NaN" />
            which are laying outside of the domain of <paramref name="V" />, as specified by <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to control the handling of those values.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<double> X = linspace</*!HC:inArr1*/double>(-pi, pi, 10);
            Array<double> V = sin(x);
            
            //define query points
            Array<double> Xn = linspace</*!HC:inArr1*/double>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<double> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or interpolations using refinement factor
            Array<double> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or just linear interpolation
            Array<double> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X" /> and <paramref name="V" /> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X" />. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method" /> at specified query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and complex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<complex> X = linspace<complex>(-pi, pi, 10);
            Array<complex> V = sin(x);
            
            //define query points
            Array<complex> Xn = linspace<complex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<complex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or interpolations using refinement factor
            Array<complex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or just linear interpolation
            Array<complex> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> for <paramref name="X" />.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X" /> and <paramref name="V" /> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn" />, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and complex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para><para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> marks any resulting values with <see cref="P:ILNumerics.complex.NaN" />
            which are laying outside of the domain of <paramref name="V" />, as specified by <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to control the handling of those values.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<complex> X = linspace<complex>(-pi, pi, 10);
            Array<complex> V = sin(x);
            
            //define query points
            Array<complex> Xn = linspace<complex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<complex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or interpolations using refinement factor
            Array<complex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or just linear interpolation
            Array<complex> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X" /> and <paramref name="V" /> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X" />. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method" /> at specified query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and fcomplex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
            Array<fcomplex> V = sin(x);
            
            //define query points
            Array<fcomplex> Xn = linspace<fcomplex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<fcomplex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or interpolations using refinement factor
            Array<fcomplex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or just linear interpolation
            Array<fcomplex> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> for <paramref name="X" />.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X" /> and <paramref name="V" /> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn" />, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and fcomplex precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para><para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> marks any resulting values with <see cref="P:ILNumerics.fcomplex.NaN" />
            which are laying outside of the domain of <paramref name="V" />, as specified by <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to control the handling of those values.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
            Array<fcomplex> V = sin(x);
            
            //define query points
            Array<fcomplex> Xn = linspace<fcomplex>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<fcomplex> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or interpolations using refinement factor
            Array<fcomplex> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or just linear interpolation
            Array<fcomplex> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X" /> and <paramref name="V" /> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="outOfRangeValues">Special value to be assigned to new query points laying outside of the range specified by <paramref name="X" />. Null: extrapolate.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] according to <paramref name="method" /> at specified query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and float precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<float> X = linspace<float>(-pi, pi, 10);
            Array<float> V = sin(x);
            
            //define query points
            Array<float> Xn = linspace<float>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<float> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or interpolations using refinement factor
            Array<float> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or just linear interpolation
            Array<float> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> for <paramref name="X" />.Length &gt; 9.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X" /> and <paramref name="V" /> have unmatching sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate data in one dimension, marking out-of-range values as NaN.
            </summary>
            <param name="V">Sample values, n-dimensional array of size [l1, l2, ... ln] with data values along the first dimension, or row vector of length l1.</param>
            <param name="X">[Optional] Positions for sample points in <paramref name="V" />; vector of length l1. Default: vec(0,l1-1).</param>
            <param name="Xn">[Optional] New query points; vector of length m. Default: (null) see parameter <paramref name="k" />.</param>
            <param name="k">[Optional] Refinement factor. If <paramref name="Xn" /> is null create new query points by splitting <paramref name="X" /> k times into half. Default: 1 (splits once).</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Returns interpolated values as array of size [m, l2,...,ln] at specified query points <paramref name="Xn" />, marking out-of range values as NaN.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> performs one dimensional
            interpolation, i.e.: interpolation based on sample values <paramref name="V" /> of one variable <paramref name="X" /> at new query points <paramref name="Xn" />.</para><para>The array <paramref name="V" /> contains the set of known sample values. If <paramref name="V" /> is a vector a vector with the same orientation and length
            <c>m</c> is returned. If <paramref name="V" /> is a n-dimensional array individual interpolations are performed for each column in <paramref name="V" />.</para><para><paramref name="X" /> defines the positions for the sample values along the columns in <paramref name="V" /> as a vector of <i>strictly monotonically increasing</i> values.
            If <paramref name="X" /> was specified as <c>null</c> a regular stepped range starting at <c>0</c> with step size <c>1</c> is assumed with the length of the working dimension in <paramref name="V" />.</para><para>The parameter <paramref name="Xn" /> holds the vector of positions for the new query points. If <paramref name="Xn" /> is ommitted query point positions
            are auto-created by splitting the ranges defined by <paramref name="X" /> into half <paramref name="k" /> times.</para>
            The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V" /> which
            is closest to a new query point. This method needs little computing ressources.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point left from a new query point; corresponds to the floor() function.
            For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension.
            This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from <paramref name="V" /> which is right from a new query point; corresponds
            to the ceil() function. If no 'next' sample is available (for extrapolating query points) the nearest sample is returned. At least 2 samples
            are required for <paramref name="V" />. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first and higher derivatives. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. The algorithm uses insignificantly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but significantly fewer ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples are required in <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise polynomial interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation for large datasets with less strict smoothness requirements.
            At least 3 respectively 4 points are required in <paramref name="V" /> for 'parabolic' and 'cubic' polynomials.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation.
            The order of the polynomial function corresponds to the number of sample points <i>V.Length</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in <paramref name="V" />.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> or the
            <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)" /> interpolation object and specify the order explicitely.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first and <i>second</i> derivatives. At least 3 sample points are required for
            <paramref name="V" />. The interpolation is the same as <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />,
            with not-a-knot boundary conditions at both end points. Consider using <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            directly if more control of the boundary conditions is needed. This method brings the smoothest results in relation to its slightly higher computational demands. Despite its
            computational complexity, due to a carefully optimized implementation its speed is competitive to the other interpolation methods.</item></list><para>All interpolation methods in ILNumerics Interpolation Toolbox are well prepared to handle arbitrary array shapes for <paramref name="V" />, including empty arrays and row vectors.
            All, single and float precision real and complex values (including NaN values) are supported. All functions are carefully parallelized for
            multicore systems and optimized for efficient, cache aware computations on large data.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> is able to interpolate multiple sets of sample
            values at once. Individual interpolations are performed for each column of n-dimensional <paramref name="V" />.</para><para>This overload of <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> marks any resulting values with <see cref="F:System.Single.NaN" />
            which are laying outside of the domain of <paramref name="V" />, as specified by <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to control the handling of those values.</para></remarks>
            <example><para><code><![CDATA[
            //Define any 1-D function
            Array<float> X = linspace<float>(-pi, pi, 10);
            Array<float> V = sin(x);
            
            //define query points
            Array<float> Xn = linspace<float>(-pi, pi, 30);
            
            //Interpolation using all values
            Array<float> Vn = Interpolation.interp1(V, X, Xn, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or interpolations using refinement factor
            Array<float> Vn = Interpolation.interp1(V, X, k:3, method: InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or just linear interpolation
            Array<float> Vn = Interpolation.interp1(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X" /> is not ascending and distinct specified.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X" /> and <paramref name="V" /> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1" /> and <paramref name="X2" />. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<double> X2 = 1;
            Array<double> X1 = meshgrid(linspace<double>(-2, 2, 20), linspace<double>(-2, 2, 20), X2);
            Array<double> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<double> Xn2 = 1;
            Array<double> Xn1 = meshgrid(linspace<double>(-3, 3, 50), linspace<double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or spline interpolate using refinement factor
            Array<double> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<double> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" /> and <paramref name="X2" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<double> X2 = 1;
            Array<double> X1 = meshgrid(linspace<Double>(-2, 2, 20), linspace<Double>(-2, 2, 20), X2);
            Array<double> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<double> Xn2 = 1;
            Array<double> Xn1 = meshgrid(linspace<Double>(-3, 3, 50), linspace<Double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: double.NaN);
            
            //or spline interpolate using refinement factor
            Array<double> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<double> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<double> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1" /> and <paramref name="X2" />. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            for a detailed description.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<complex> X2 = 1;
            Array<complex> X1 = meshgrid(linspace<complex>(-2, 2, 20), linspace<complex>(-2, 2, 20), X2);
            Array<complex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<complex> Xn2 = 1;
            Array<complex> Xn1 = meshgrid(linspace<complex>(-3, 3, 50), linspace<complex>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or spline interpolate using refinement factor
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<complex> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="!:interp2(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="!:interp2(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" /> and <paramref name="X2" />. Use the overload <see cref="!:interp2(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<complex> X2 = 1;
            Array<complex> X1 = meshgrid(linspace<double>(-2, 2, 20), linspace<double>(-2, 2, 20), X2);
            Array<complex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<complex> Xn2 = 1;
            Array<complex> Xn1 = meshgrid(linspace<double>(-3, 3, 50), linspace<double>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: complex.NaN);
            
            //or spline interpolate using refinement factor
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<complex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<complex> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1" /> and <paramref name="X2" />. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            for a detailed description.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<fcomplex> X2 = 1;
            Array<fcomplex> X1 = meshgrid(linspace<fcomplex>(-2, 2, 20), linspace<fcomplex>(-2, 2, 20), X2);
            Array<fcomplex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<fcomplex> Xn2 = 1;
            Array<fcomplex> Xn1 = meshgrid(linspace<fcomplex>(-3, 3, 50), linspace<fcomplex>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolate using refinement factor
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<fcomplex> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="!:interp2(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="!:interp2(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" /> and <paramref name="X2" />. Use the overload <see cref="!:interp2(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<fcomplex> X2 = 1;
            Array<fcomplex> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<fcomplex> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<fcomplex> Xn2 = 1;
            Array<fcomplex> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolate using refinement factor
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<fcomplex> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<fcomplex> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="outOfRangeValues">Scalar value used to mark values whose position lays outside the range defined by <paramref name="X1" /> and <paramref name="X2" />. Null: extrapolate.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<float> X2 = 1;
            Array<float> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<float> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<float> Xn2 = 1;
            Array<float> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or spline interpolate using refinement factor
            Array<float> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<float> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 2D data.
            </summary>
            <param name="V">Matrix with sample values defined in meshgrid format.</param>
            <param name="X1">[Optional] Positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the rows.</param>
            <param name="X2">[Optional] Positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or grid vector. Monotonically increasing along the columns.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1 (rows), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2 (columns), specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" /> and/or <paramref name="X2" /> are split
            <paramref name="k" /> times. Ignored for <paramref name="Xn1" /> or <paramref name="Xn2" /> being not null respectively. Default: 1.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>Matrix with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs two dimensional interpolation over the given data matrix <paramref name="V" /> defined in <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            format. The parameter <paramref name="X1" /> specifies the positions of the grid points in <paramref name="V" /> along the first dimension (along the rows of V).
            <paramref name="X2" /> determines the positions along the 2nd dimension (along the columns of <paramref name="V" />). Hence, <paramref name="V" /> forms a regular,
            rectilinear grid of (non-)uniform spacing. Note the order of the dimensions in <paramref name="V" />: as determined by the meshgrid function the first dimension is considered to correspond to the <i>rows</i>
            instead of the columns. This order is useful for visualization purposes and plotting, where the X axis is commonly expected along the rows. Use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            as an alternative.</para><para>Values in <paramref name="X1" /> and <paramref name="X2" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" /> and/or <paramref name="X2" /> are ommitted, default grid positions are assumed with uniform range of spacing 1: 0:n x 0:m, where [m+1,n+1] = size(V).</para><para>Values in <paramref name="Xn1" /> and <paramref name="Xn2" />, if provided, must be strictly monotonically increasing but not necessarily uniform. If any of
            <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are ommitted, default query grid positions are assumed by subdividing <paramref name="X1" /> and/or <paramref name="X2" />
            respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" /> and <paramref name="X2" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            with an additional 'outOfRange' parameter in order to specify another value for out-of-range points or to create extrapolated values for them by specifying the outOfRange parameter as <c>null</c>.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid
            Array<float> X2 = 1;
            Array<float> X1 = meshgrid(linspace<float>(-2, 2, 20), linspace<float>(-2, 2, 20), X2);
            Array<float> V = X1 * exp(-(X1 * X1 + X2 * X2));
            
            //define query meshgrid
            Array<float> Xn2 = 1;
            Array<float> Xn1 = meshgrid(linspace<float>(-3, 3, 50), linspace<float>(-3, 3, 50), Xn2);
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.spline, outOfRangeValues: float.NaN);
            
            //or spline interpolate using refinement factor
            Array<float> Vq = Interpolation.interp2(V, X1, X2, k:2, method:InterpolationMethod.spline);
            
            //or nearest neighbor interpolation of a meshgrid with only one Xn2 specified.
            Array<float> Vq = Interpolation.interp2(V, X1, X2, Xn2:Xn2, method:InterpolationMethod.nearest);
            
            //or linear interpolate a meshgrid
            Array<float> Vq = Interpolation.interp2(V);
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="method" /> is set as global polynomial for more than 9 sample points <paramref name="X1" /> or <paramref name="X2" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If arguments <paramref name="X1" /> or <paramref name="X2" /> do not match the size of <paramref name="V" />.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V" /> or <c>null</c> for extrapolation.</param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate a meshgrid [-1:1]
            Array<double> Y = 1.0f;
            Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
            Array<double> V = sqrt(1 - X * X - Y * Y);
            
            //define random scattered points [-1:1]
            Array<Double> Xn = 2 * rand(3000, 1) - 1;
            Array<Double> Yn = 2 * rand(3000, 1) - 1;
            
            //Linear interpolation
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: double.NaN);
            
            //or spline interpolation without range definition
            Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls return an empty array, because query points not set
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<double> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<double> Y = 1.0f;
            Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
            Array<double> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<Double> Xn = 2 * rand(3000, 1) - 1;
            Array<Double> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: double.NaN);
            
            //or spline interpolation without range definition
            Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<double> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V" /> or <c>null</c> for extrapolation.</param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate a meshgrid [-1:1]
            Array<complex> Y = 1.0f;
            Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
            Array<complex> V = sqrt(1 - X * X - Y * Y);
            
            //define random scattered points [-1:1]
            Array<double> Xn = 2 * rand(3000, 1) - 1;
            Array<double> Yn = 2 * rand(3000, 1) - 1;
            
            //Linear interpolation
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: complex.NaN);
            
            //or spline interpolation without range definition
            Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls return an empty array, because query points not set
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<complex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="!:interp2s(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<complex> Y = 1.0f;
            Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
            Array<complex> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<double> Xn = 2 * rand(3000, 1) - 1;
            Array<double> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: complex.NaN);
            
            //or spline interpolation without range definition
            Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<complex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V" /> or <c>null</c> for extrapolation.</param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate a meshgrid [-1:1]
            Array<fcomplex> Y = 1.0f;
            Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
            //define random scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Linear interpolation
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolation without range definition
            Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls return an empty array, because query points not set
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<fcomplex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="!:interp2s(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<fcomplex> Y = 1.0f;
            Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolation without range definition
            Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<fcomplex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <param name="outOfRangeValues">Fixed value for query points outside of the domain of <paramref name="V" /> or <c>null</c> for extrapolation.</param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate a meshgrid [-1:1]
            Array<float> Y = 1.0f;
            Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<float> V = sqrt(1 - X * X - Y * Y);
            
            //define random scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Linear interpolation
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, outOfRangeValues: float.NaN);
            
            //or spline interpolation without range definition
            Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls return an empty array, because query points not set
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<float> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are not strictly monotonically increasing.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and/or <paramref name="Xn2" /> are null or have different sizes.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp2s(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>2</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" /> and <paramref name="Xn2" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" /> performs interpolation
            of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges for any dimension,
            new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation are specified dimension-wise in <paramref name="Xn1" /> and <paramref name="Xn2" />.
            Therefore, the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. None of <paramref name="Xn1" /> and <paramref name="Xn2" />
            can be null. </para><para>The positions of the grid elements in <paramref name="V" /> are specified in <paramref name="X1" /> for the rows in <paramref name="V" /> and <paramref name="X2" /> for
            the columns in <paramref name="V" />. Any dimension specified as <c>null</c> in <paramref name="X1" /> or <paramref name="X2" /> are considered as auto-ranged with values
            from <c>0</c>...<c>size(V,0)-1</c> or <c>0</c>...<c>size(V,1)-1</c> correspondingly. Otherwise, <paramref name="X1" /> and <paramref name="X2" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>The array returned is of size 2 x n, where n corresponds to the number of elements in <paramref name="Xn1" /> and <paramref name="Xn2" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<float> Y = 1.0f;
            Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<float> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: float.NaN);
            
            //or spline interpolation without range definition
            Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<float> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value used to mark those values whose position lays outside the range defined by <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate query points on a regular grid from gridded 3D data.
            </summary>
            <param name="V">3 dimensional array with sample values.</param>
            <param name="X1">[Optional] Positions of grid points in <paramref name="V" /> for dimension 1, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X2">[Optional] Positions of grid points in <paramref name="V" /> for dimension 2, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="X3">[Optional] Positions of grid points in <paramref name="V" /> for dimension 3, specified as a matrix in meshgrid format or grid vector. Monotonically increasing.</param>
            <param name="Xn1">[Optional] Query point positions for dimension 1, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn2">[Optional] Query point positions for dimension 2, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="Xn3">[Optional] Query point positions for dimension 3, specified as grid vector or matrix in meshgrid format. Monotonically increasing.</param>
            <param name="k">[Optional] Refinement factor for default query grid positions. Ranges specified by <paramref name="X1" />,<paramref name="X2" /> and/or <paramref name="X3" /> are split
            <paramref name="k" /> times. Ignored for any of <paramref name="Xn1" />, <paramref name="Xn2" /> or <paramref name="Xn3" /> being not null.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>3 dimensional array with interpolated values. Corresponds to the grid determined by <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            performs three dimensional interpolation over the given data array <paramref name="V" />. The parameter <paramref name="X1" /> specifies the
            positions of the grid points in <paramref name="V" /> along the first dimension (the columns of V). <paramref name="X2" /> determines the positions along the
            2nd dimension (rows of <paramref name="V" />) and so forth. Hence, <paramref name="V" /> forms a regular, rectilinear grid of (non-)uniform spacing in three dimensions.</para><para>Values in <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />, if provided, must be strictly monotonically increasing but not necessarily be uniform. If any
            of <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> are ommitted for dimension d, default grid positions are assumed with uniform range of spacing 1:
            0:1:m, where m = size(V, d).</para><para>Values in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />, if provided, must be strictly monotonically increasing but not necessarily have
            uniform spacing. If any of <paramref name="Xn1" />, <paramref name="Xn2" /> and/or <paramref name="Xn3" /> are ommitted, default query grid positions are assumed by subdividing
            <paramref name="X1" />, <paramref name="X2" /> and/or <paramref name="X3" /> respectively, '<paramref name="k" />' times.</para><para>Interpolation methods: all methods from the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> are supported. See <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            for a detailed description.</para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X1" />, <paramref name="X2" /> and <paramref name="X3" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3s(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>3</sup>.
            </summary>
            <param name="V">Known values, specified as 3D array in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X3">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="!:interp3s(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InterpolationMethod)" />
            performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with
            uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation
            are specified dimension-wise in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.
            Therefore, the number of elements in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. <paramref name="Xn3" /> defines the Z coordinates.
            None of <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> can be null.</para><para>The positions of the grid elements in <paramref name="V" /> are specified as grid vectors in <paramref name="X1" /> for the rows in <paramref name="V" /> and
            <paramref name="X2" />/ <paramref name="X3" /> for the columns / 3rd dimension in <paramref name="V" />. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1" />.. <paramref name="X3" />
            are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1" /> ... <paramref name="X3" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> or <paramref name="Xn3" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1" /> ... <paramref name="Xn3" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<fcomplex> Y = 1.0f;
            Array<fcomplex> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<fcomplex> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: fcomplex.NaN);
            
            //or spline interpolation without range definition
            Array<fcomplex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<fcomplex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<fcomplex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3s(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>3</sup>.
            </summary>
            <param name="V">Known values, specified as 3D array in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X3">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with
            uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation
            are specified dimension-wise in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.
            Therefore, the number of elements in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. <paramref name="Xn3" /> defines the Z coordinates.
            None of <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> can be null.</para><para>The positions of the grid elements in <paramref name="V" /> are specified as grid vectors in <paramref name="X1" /> for the rows in <paramref name="V" /> and
            <paramref name="X2" />/ <paramref name="X3" /> for the columns / 3rd dimension in <paramref name="V" />. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1" />.. <paramref name="X3" />
            are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1" /> ... <paramref name="X3" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> or <paramref name="Xn3" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1" /> ... <paramref name="Xn3" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<float> Y = 1.0f;
            Array<float> X = meshgrid(linspace<float>(-1, 1, 20), linspace<float>(-1, 1, 20), Y);
            Array<float> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<float> Xn = 2 * rand(3000, 1) - 1;
            Array<float> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: float.NaN);
            
            //or spline interpolation without range definition
            Array<float> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<float> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<float> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3s(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>3</sup>.
            </summary>
            <param name="V">Known values, specified as 3D array in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X3">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3s(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with
            uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation
            are specified dimension-wise in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.
            Therefore, the number of elements in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. <paramref name="Xn3" /> defines the Z coordinates.
            None of <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> can be null.</para><para>The positions of the grid elements in <paramref name="V" /> are specified as grid vectors in <paramref name="X1" /> for the rows in <paramref name="V" /> and
            <paramref name="X2" />/ <paramref name="X3" /> for the columns / 3rd dimension in <paramref name="V" />. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1" />.. <paramref name="X3" />
            are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1" /> ... <paramref name="X3" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> or <paramref name="Xn3" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1" /> ... <paramref name="Xn3" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<double> Y = 1.0f;
            Array<double> X = meshgrid(linspace<Double>(-1, 1, 20), linspace<Double>(-1, 1, 20), Y);
            Array<double> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<Double> Xn = 2 * rand(3000, 1) - 1;
            Array<Double> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: double.NaN);
            
            //or spline interpolation without range definition
            Array<double> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<double> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<double> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interp3s(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>3</sup>.
            </summary>
            <param name="V">Known values, specified as 3D array in meshgrid format.</param>
            <param name="X1">Sample positions of grid points along the rows of <paramref name="V" />, specified as a 3D array in meshgrid format or as grid vector, or null for auto uniform range.</param>
            <param name="X2">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="X3">Sample positions of grid points along the columns of <paramref name="V" />, specified as a matrix in meshgrid format or as vector, or null for auto uniform range.</param>
            <param name="Xn1">Query points X-coordinates, real array of arbitrary shape.</param>
            <param name="Xn2">Query points Y-coordinates, real array of arbitrary shape.</param>
            <param name="Xn3">Query points Z-coordinates, real array of arbitrary shape.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Interpolated values at query points given in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.</returns>
            <remarks><para><see cref="!:interp3s(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InterpolationMethod)" />
            performs interpolation of individual scattered points on the two-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with
            uniform or non-uniform ranges for any dimension, new query points for interpolation are scattered and not arranged in a grid. The query points for interpolation
            are specified dimension-wise in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" />.
            Therefore, the number of elements in <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> must match. <paramref name="Xn1" /> specifies the coordinates in the first
            dimension (X coordinates) of the query points, corresponding to the direction of the rows in <paramref name="V" />. <paramref name="Xn2" /> specifies the coordinates in the
            second dimension (Y coordinates) of the query points, corresponding to the direction of the columns in <paramref name="V" />. <paramref name="Xn3" /> defines the Z coordinates.
            None of <paramref name="Xn1" />, <paramref name="Xn2" /> and <paramref name="Xn3" /> can be null.</para><para>The positions of the grid elements in <paramref name="V" /> are specified as grid vectors in <paramref name="X1" /> for the rows in <paramref name="V" /> and
            <paramref name="X2" />/ <paramref name="X3" /> for the columns / 3rd dimension in <paramref name="V" />. Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X1" />.. <paramref name="X3" />
            are considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c> correspondingly. Otherwise, <paramref name="X1" /> ... <paramref name="X3" /> must be arrays with
            strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn1" /> or <paramref name="Xn2" /> or <paramref name="Xn3" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size 3 x l, where l corresponds to the number of query points provided in <paramref name="Xn1" /> ... <paramref name="Xn3" />.</para></remarks>
            <example><para><code><![CDATA[
            
            //generate any meshgrid [-1:1]
            Array<complex> Y = 1.0f;
            Array<complex> X = meshgrid(linspace<double>(-1, 1, 20), linspace<double>(-1, 1, 20), Y);
            Array<complex> V = sqrt(1 - X * X - Y * Y);
            
            //define random generated scattered points [-1:1]
            Array<double> Xn = 2 * rand(3000, 1) - 1;
            Array<double> Yn = 2 * rand(3000, 1) - 1;
            
            //Interpolate
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, Xn1, Xn2, method:InterpolationMethod.linear, outOfRangeValues: complex.NaN);
            
            //or spline interpolation without range definition
            Array<complex> Vq = Interpolation.interp2s(V, Xn1:Xn, Xn2:Yn, method:InterpolationMethod.spline);
            
            //this two function calls returns an empty array, because query points not set
            Array<complex> Vq = Interpolation.interp2s(V, X1, X2, method:InterpolationMethod.nearest);
            //or
            Array<complex> Vq = Interpolation.interp2s(V);
            
            ]]></code></para></example>
            <exception cref="T:System.ArgumentNullException">If input parameter <paramref name="V" /> is NULL</exception>
            <exception cref="T:System.ArgumentException">If argument <paramref name="X1" /> or <paramref name="X2" /> are found to be not strictly monotonically ascending.</exception>
            <exception cref="T:System.ArgumentException">If arguments <paramref name="Xn1" /> and <paramref name="Xn2" /> have different number of elements.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X" />.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;double&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'Double' since this gives both: best performance and best precision. Other element types are converted to
            double arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>If <paramref name="outOfRangeValues" /> is given as <c>null</c> affected elements will be extrapolated from the existing sample points
            according to <paramref name="method" />. Otherwise, the value given in <paramref name="outOfRangeValues" /> is assigned to these query points.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X" />. Use the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any cell element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;double&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'Double' since it gives both: best performance and best precision. Other element types are converted to
            Double arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns NaN to all query points laying outside
            of the range as specified in <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X" />.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;complex&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'double' since this gives both: best performance and best precision. Other element types are converted to
            complex arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>If <paramref name="outOfRangeValues" /> is given as <c>null</c> affected elements will be extrapolated from the existing sample points
            according to <paramref name="method" />. Otherwise, the value given in <paramref name="outOfRangeValues" /> is assigned to these query points.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X" />. Use the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any cell element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;complex&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'double' since it gives both: best performance and best precision. Other element types are converted to
            double arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns NaN to all query points laying outside
            of the range as specified in <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X" />.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;fcomplex&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'float' since this gives both: best performance and best precision. Other element types are converted to
            fcomplex arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>If <paramref name="outOfRangeValues" /> is given as <c>null</c> affected elements will be extrapolated from the existing sample points
            according to <paramref name="method" />. Otherwise, the value given in <paramref name="outOfRangeValues" /> is assigned to these query points.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X" />. Use the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any cell element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;fcomplex&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'float' since it gives both: best performance and best precision. Other element types are converted to
            float arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns NaN to all query points laying outside
            of the range as specified in <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with sample values.</param>
            <param name="outOfRangeValues">Scalar value marking elements in the resulting array whose position exceeds the range determined by <paramref name="X" />.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension on <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values as determined by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent, i.e.: grid elements along any dimension are not necessarily equally spaced.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the distances between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;float&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'float' since this gives both: best performance and best precision. Other element types are converted to
            float arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>If <paramref name="outOfRangeValues" /> is given as <c>null</c> affected elements will be extrapolated from the existing sample points
            according to <paramref name="method" />. Otherwise, the value given in <paramref name="outOfRangeValues" /> is assigned to these query points.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Gridded data interpolation in n dimensions
            </summary>
            <param name="V">N-dimensional array with known values.</param>
            <param name="X">[Optional] Cell array with range definitions for each dimension in <paramref name="V" />. Default (null): assume uniform spacing of length 1.</param>
            <param name="Xn">[Optional] New query points. Cell vector of length N. Default: (null) define new points by subdividing ranges given in <paramref name="X" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />.</param>
            <returns>N-dimensional array with interpolated values. The size corresponds to the ranges given by <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> interpolates new points from a rectilinear,
            uniform or non-uniform grid of sample points. Both, the set of sampled values <paramref name="V" /> as well as the set of new query points <paramref name="Xn" />
            are expected as a <i>rectilinear</i> n-dimensional grid. A rectilinear grid exposes square angles in all crossings of grid lines. However,
            individual grid elements (simplex or hyper cubes) are not necessarily congruent.</para><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns
            NaN to all query points laying outside of the range of <paramref name="X" />. Use the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out-of-range or to create extrapolated values for them by specifying its outOfRange parameter as null.</para><para>As a special case <paramref name="V" /> can be a row vector or a column vector. In this case <paramref name="X" /> and <paramref name="Xn" />
            are expected as vectors (hence one dimensional) and a shape preserving 1-dimensional interpolation is performed on the values of <paramref name="V" />.</para><para>In the general case <paramref name="X" /> and <paramref name="Xn" /> are cell containers, each holding N vectors of range definitions.
            <paramref name="X" /> describes the 'coordinates' for the N dimensions of <paramref name="V" />. <paramref name="Xn" /> specifies the grid of new query points
            to be interpolated. Here, <paramref name="Xn" /> determines a hyper cube of N dimensions. Each array from <paramref name="Xn" /> corresponds
            to one dimension of the resulting N-dim array.</para><para>Cell array elements in both, <paramref name="X" /> and <paramref name="Xn" /> must be arrays with strictly monotonically increasing numerical elements. They form a
            regular grid which, however, is not required to be equally spaced. So the <i>distances</i> between elements within one dimension range in
            <paramref name="X" /> and <paramref name="Xn" /> can be arbitrary.</para><para>Any cell element specified in <paramref name="X" /> for a specific dimension <c>i</c> must match the length of the corresponding
            dimension in <paramref name="V" />, i.e. <code>X.GetArray&lt;float&gt;(i).S.NumberOfElements == V.S[i]</code>. For any cell element in <paramref name="X" />
            which is not specified (<c>null</c>) for dimension <c>i</c> the corresponding range in <paramref name="V" /> is assumed to be: <c>vec(0,1,size(V,i)-1)</c>.
            If <paramref name="Xn" /> equals <c>null</c> all dimensions in <paramref name="V" /> are auto generated.</para><para>Cell elements in <paramref name="X" /> and <paramref name="Xn" /> may have any numeric element type. However, it is recommended to provide these ranges
            as <see cref="T:ILNumerics.Array`1" /> of element type 'float' since it gives both: best performance and best precision. Other element types are converted to
            float arrays internally.</para><para>The <paramref name="method" /> parameter determines the algorithm used for interpolation. The default method is
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" />. The following methods are supported:
            <list type="bullet"><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" /> - Nearest neighbor interpolation returns the nearest sample point in terms of its
            euclidean distance to a query point. This method needs little ressources and is recommended for 'large' and 'huge' data (what ever that means
            in relation to your hardware).</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous" /> - returns the sample point from the surrounding hyper cube with the smallest index
            in each dimension, corresponds to the floor() function. For query points outside of the specified domain the nearest available sample point is returned.
            At least 2 samples are required in each dimension. This function requires little resources and performs at about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next" /> - returns the sample point from the surrounding hyper cube with the highest index in each
            dimension, corresponds to the ceil() function. If no 'next' sample is available (for extrapolating query points) the last edge sample is returned.
            At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /> - Linear interpolation between adjacent sample points, produces continous function values
            but discontinuities in the first derivative. One will notice that the slopes of the interpolation result will change abruptly at the sample
            points. This method is efficiently implemented and carefully optimized. It is most efficient for query sets having a significant number of
            query points lined up along the first dimension. The algorithm uses slightly more ressources than <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest" />
            but fewer ressources as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.
            At least two samples in each dimension are needed in each working dimension of <paramref name="V" /> for linear interpolation.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />, <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.pp" /> -
            Piecewise cubic interpolation builds up a polynomial of order 2 or 3 respectively, based on the 3 or 4 points surrounding a query point.
            The interpolation result will be smooth in the function values and its first derivatives, but may introduce jumps in the second derivatives
            at the sample points. Due to its computational simplicity <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> interpolation is able to serve as a quick alternative
            for large datasets with less strict smoothness requirements as an alternative to <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> interpolation.
            At least 3 or 4 points are required in <paramref name="V" /> in each dimension for 'parabolic' and 'cubic' polynomials respectively.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> - performs <i>global</i> polynomial interpolation along each dimension <c>i</c>separately.
            The order of the polynomial function corresponds to the number of sample points <i>V.S[i]-1</i> along dimension <i>i</i>. Due to the nature of
            higher order polynomials such 'global' interpolation is best suited for small sample sets with 3...7 sample values in each dimension of V.
            For larger data, consider using one of the piecewise interpolations, like <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" /> or <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" />.</item><item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.spline" /> - cubic spline interpolation produces the smoothest results in terms of function values as well
            as its first <i>and</i> second derivatives. For uniform <paramref name="V" /> (i.e. elements of X are equally spaced within each dimension but not
            necessarily have the same spacing among all dimensions) an efficient N-D implementation of Catmull-Rom splines is used. Query points at the edges
            of <paramref name="V" /> are computed by help of virtual query points extending the domain of X in each direction. For non-uniform
            <paramref name="X" /> general cubic splines are applied with not-a-knot boundary condition.  At least 3 sample points are required for
            <paramref name="V" /> in each (working) dimension. One may use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> directly if more
            control of the boundary conditions is needed. This method brings the smoothest results among all methods listed here - to the price of slightly higher
            computational demands.</item></list></para><para>By default <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> assigns NaN to all query points laying outside
            of the range as specified in <paramref name="X" />. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            in order to specify another value for grid points laying out of range or to create extrapolated values for them by specifying the outOfRange parameter as null.</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp3(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if any of the input parameter is invalid.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Cell array with n numeric arrays describing the coordinates of the <c>l</c> query points.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range: NaN will be assigned to it.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="outOfRangeValues">Fixed scalar value to be assigned to query points laying outside of the domain of <paramref name="V" />.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported, with the exception of <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.polynomial" /> and
            <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.parabolic" />. By default, linear interpolation is performed.</para><para><paramref name="V" /> may contain NaN values. Depending on the interpolation method used interpolated query points on surronding hypercubes will return NaN as well.</para><para>Any elements in <paramref name="Xn" /> being NaN will cause the corresponding interpolation result to be considered as 'out of range:
            the value given in <paramref name="outOfRangeValues" /> will be assigned to it. If <paramref name="outOfRangeValues" /> is <c>null</c> those elements are mapped to the first grid
            element in <paramref name="V" />.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked with the value provided in <paramref name="outOfRangeValues" />. Set this value to <c>null</c>
            in order to achieve extrapolation for those values.</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
            <summary>
            Interpolate scattered query points from gridded sample data in R<sup>n</sup>.
            </summary>
            <param name="V">Known values, specified as matrix in meshgrid format.</param>
            <param name="X">Sample positions of grid points in <paramref name="V" />, specified as cell array elements for each dimension in <paramref name="V" />.</param>
            <param name="Xn">Matrix, [n x l] with the coordinates of the query points in <c>l</c> columns of length <c>n</c>.</param>
            <param name="method">[Optional] Interpolation method. Default: <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.linear" /></param>
            <returns>Row vector with interpolated values at query points <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> performs n-dimensional interpolation
            of individual scattered points on the n-dimensional domain <paramref name="V" />. While V corresponds to a rectilinear grid with uniform or non-uniform ranges
            for any dimension, new query points for interpolation are layed out in a scattered manner and not arranged in a grid. The query points for interpolation are
            specified dimension-wise in the individual cell elements of <paramref name="Xn" />. Therefore, all such cells elements must be not <c>null</c> and have all
            the same number of elements.</para><para>The positions of the grid elements in <paramref name="V" /> are specified by <paramref name="X" /> for the individual dimensions in <paramref name="V" />.
            Any dimension <c>i</c> specified as <c>null</c> in <paramref name="X" /> is considered as auto-ranged with values from <c>0</c>...<c>size(V,i)-1</c>. Otherwise,
            all arrays provided in <paramref name="X" /> must have strictly monotonically increasing elements.</para><para>Any interpolation method out of the enum <see cref="T:ILNumerics.Toolboxes.InterpolationMethod" /> is supported. By default, linear interpolation is performed.</para><para>Any elements outside of the domain of <paramref name="V" /> are marked as NaN (not a number).</para><para>The array returned is of size [n x l], where l corresponds to the length of the arrays in <paramref name="Xn" />, i.e. the number of query points.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.kriging(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.OutArray{System.Double})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X" />. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})" /></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X" /> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn" /></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation.
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X" />. The algorithm will remove any points
            being too close to each in order to increase stability of the algorithm.</para><para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para><para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X" /> or <paramref name="V" /> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X" /> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.kriging(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.OutArray{System.Double})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X" />. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})" /></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X" /> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn" /></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation.
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X" />. The algorithm will remove any points
            being too close to each in order to increase stability of the algorithm.</para><para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para><para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X" /> or <paramref name="V" /> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X" /> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.kriging(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.OutArray{System.Single})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X" />. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})" /></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X" /> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn" /></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation.
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X" />. The algorithm will remove any points
            being too close to each in order to increase stability of the algorithm.</para><para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para><para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X" /> or <paramref name="V" /> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X" /> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.kriging(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.OutArray{System.Single})">
            <summary>
            Kriging interpolation from scattered data
            </summary>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="V">Data values, matrix with measured values at the n data points provided by <paramref name="X" />. Size [k x n].</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})" /></param>
            <param name="Xn">New points to compute interpolated values for. The format corresponds to the <paramref name="X" /> parameter. Size [k x l].</param>
            <param name="error">[Optional] if not null on input error information will be returned.</param>
            <returns>Interpolated values for each point (column) provided in <paramref name="Xn" /></returns>
            <remarks>Kriging interpolation learns a hidden function from the given data based on statistical properties of the data. Kriging is well suited for scattered data interpolation.
            <para>The interpolation is based on the geometrical relation of the points provided in <paramref name="X" />. The algorithm will remove any points
            being too close to each in order to increase stability of the algorithm.</para><para>While the default variogram function is fine in most situations one can provide a custom variogram function to the interpolation.</para><para>More details are found in the <a href="http://ilnumerics.net/kriging-interpolation-net.html">online documentation</a>.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X" /> or <paramref name="V" /> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X" /> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"]. However, all dimensions of the
            original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" /> is not provided
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> control the derivatives at the lower bound and at the upper bound of the sampled domain. The
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para><para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" />.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" /> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V" /> is required.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"].
            However, all dimensions of the original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" />
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter
            ('outOfRangeValues') from the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            in order to control this value or to get extrapolated values instead.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" /> function serves as a wrapper for
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object directly if optimal performance for multiple interpolations based
            on the same dataset <paramref name="V" /> is required.</para><para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V" />.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"]. However, all dimensions of the
            original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" /> is not provided
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> control the derivatives at the lower bound and at the upper bound of the sampled domain. The
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para><para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" /> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V" /> is required.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"].
            However, all dimensions of the original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" />
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter
            ('outOfRangeValues') from the overload <see cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)" />
            in order to control this value or to get extrapolated values instead.</para><para>The <see cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)" /> function serves as a wrapper for
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object directly if optimal performance for multiple interpolations based
            on the same dataset <paramref name="V" /> is required.</para><para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V" />.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" />
            <seealso cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"]. However, all dimensions of the
            original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" /> is not provided
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> control the derivatives at the lower bound and at the upper bound of the sampled domain. The
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para><para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" />.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" /> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V" /> is required.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"].
            However, all dimensions of the original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" />
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter
            ('outOfRangeValues') from the overload <see cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)" />
            in order to control this value or to get extrapolated values instead.</para><para>The <see cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)" /> function serves as a wrapper for
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object directly if optimal performance for multiple interpolations based
            on the same dataset <paramref name="V" /> is required.</para><para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V" />.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" />
            <seealso cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or n-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="outOfRangeValue">Scalar value to get assigned to all new query points laying outside of the specified domain of V. Null: extrapolate.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with Xn.Length interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a n-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"]. However, all dimensions of the
            original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" /> is not provided
            (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> control the derivatives at the lower bound and at the upper bound of the sampled domain. The
            default values <c>null</c> compute so called 'not-a-knot' splines, i.e. the 1st, 2nd and 3rd derivatives at these ends are considered equal to the corresponding derivatives at their next
            available inner sampled values. This corresponds to simply extending the spline function at the first and last inner samples to the end points, hence the name 'not-a-knot'.</para><para>For other options for end point derivatives see the documentation for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" />.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" /> function serves as a wrapper for the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object
            for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object
            directly if optimal performance for multiple interpolations based on the same dataset <paramref name="V" /> is required.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})">
            <summary>
            One dimensional cubic spline interpolation.
            </summary>
            <param name="V">Sampled values as columns of a matrix or multi-dimensional array. Size [n x m], n: number of points per sample set (column length), m: number of measurements.</param>
            <param name="X">[Optional] Vector with positions for values in <paramref name="V" />. Default: (null) assumes spacing of 1.0 between row elements in <paramref name="V" />.</param>
            <param name="Xn">[Optional] Vector of length k with new query points to interpolate. Default: (null) create new points by subdividing the ranges from <paramref name="X" /> once.</param>
            <param name="lbDeriv">[Optional] Vector of length m with first derivative(s) at the lower end of each sample set. Default (null): not-a-knot spline.</param>
            <param name="ubDeriv">[Optional] Vector of length m with first derivative(s) at the upper end of each sample set. Default (null): not-a-knot spline.</param>
            <returns>Array of the same size as V, having the working dimension replaced with <c>Xn.Length</c> interpolated values.</returns>
            <remarks><para>Each column in <paramref name="V" /> is treated as an independent set of sampled values. A piecewise cubic spline interpolation is performed for each column individually.</para><para><paramref name="V" /> can be a multi-dimensional array in which case the interpolation is done on a reshaped version of <paramref name="V" /> = V[":;:"].
            However, all dimensions of the original <paramref name="V" /> are retained and considered for the return value (shape preserving).</para><para>While the rows of <paramref name="V" /> hold the ensemble of measurements for each sample position, <paramref name="X" /> holds the coordinates of these positions. If
            <paramref name="X" /> is provided it must be a vector of length n with <i>strictly monotonically increasing</i> values, without any duplicates. If <paramref name="X" />
            is not provided (<c>null</c>) unit spacing of the row elements in V is assumed: 0..1..2..n-1.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter
            ('outOfRangeValues') from the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            in order to control this value or to get extrapolated values instead.</para><para>The <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" /> function serves as a wrapper for
            the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object for syntactic convenience. Subsequent calls of spline() on the same data will recreate all temporary information
            necessary for the interpolation. Consider using the <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object directly if optimal performance for multiple interpolations based
            on the same dataset <paramref name="V" /> is required.</para><para>Spline interpolation requires <c>n &gt;= 4</c>, i.e.: at least 4 elements in the working dimension of <paramref name="V" />.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids.
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X" />). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1" /> corresponding to element type of <paramref name="V" />) with the <i>strictly monotonically increasing</i> range specification
            for the corresponding dimension in <paramref name="V" />. The spacing between elements within each dimension must not be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="Xn" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual
            arrays in the cell <paramref name="Xn" /> form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />,
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for the corresponding dimension in <paramref name="V" />,
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X" />. Every grid cell determined
            by <paramref name="X" /> is therefore split into half, roughly doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />.</para><para>Algorithm for uniform <paramref name="V" />: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> for uniform data <paramref name="V" /> (as specified by <paramref name="X" />)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X" /> to the unit interval [0,1] and applying the new positions to
            the surrounding two hypercubes in each dimension of <paramref name="V" />. The algorithm is optimized
            for large data <paramref name="V" /> and fine <paramref name="Xn" /> grids. Fastest results are obtained when many new query points are to be computed per hypercube
            in <paramref name="V" /> and if these points are arranged along the first dimension of <paramref name="V" />. I.e: when a significant large range was provided in <paramref name="Xn" />[0].</para><para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para><para>On non-uniform data <paramref name="V" /> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />.
            </para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid.
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of <paramref name="V" />) with <i>strictly
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V" />. The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />, the grid of new values is
            always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for
            the corresponding dimension in <paramref name="V" />, the ranges for the new values in the corresponding dimension to be returned are computed by
            refining the existing range from <paramref name="X" />. Every grid cell determined by <paramref name="X" /> is therefore split into half, roughly
            doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> offers.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />. Good performance is achieved via
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids.
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X" />). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1" /> corresponding to element type of <paramref name="V" />) with the <i>strictly monotonically increasing</i> range specification
            for the corresponding dimension in <paramref name="V" />. The spacing between elements within each dimension must not be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="Xn" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual
            arrays in the cell <paramref name="Xn" /> form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />,
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for the corresponding dimension in <paramref name="V" />,
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X" />. Every grid cell determined
            by <paramref name="X" /> is therefore split into half, roughly doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />.</para><para>Algorithm for uniform <paramref name="V" />: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> for uniform data <paramref name="V" /> (as specified by <paramref name="X" />)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X" /> to the unit interval [0,1] and applying the new positions to
            the surrounding two hypercubes in each dimension of <paramref name="V" />. The algorithm is optimized
            for large data <paramref name="V" /> and fine <paramref name="Xn" /> grids. Fastest results are obtained when many new query points are to be computed per hypercube
            in <paramref name="V" /> and if these points are arranged along the first dimension of <paramref name="V" />. I.e: when a significant large range was provided in <paramref name="Xn" />[0].</para><para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para><para>On non-uniform data <paramref name="V" /> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />.
            </para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid.
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of <paramref name="V" />) with <i>strictly
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V" />. The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />, the grid of new values is
            always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for
            the corresponding dimension in <paramref name="V" />, the ranges for the new values in the corresponding dimension to be returned are computed by
            refining the existing range from <paramref name="X" />. Every grid cell determined by <paramref name="X" /> is therefore split into half, roughly
            doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> offers.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex})" />. Good performance is achieved via
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids.
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X" />). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1" /> corresponding to element type of <paramref name="V" />) with the <i>strictly monotonically increasing</i> range specification
            for the corresponding dimension in <paramref name="V" />. The spacing between elements within each dimension must not be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="Xn" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual
            arrays in the cell <paramref name="Xn" /> form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />,
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for the corresponding dimension in <paramref name="V" />,
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X" />. Every grid cell determined
            by <paramref name="X" /> is therefore split into half, roughly doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />.</para><para>Algorithm for uniform <paramref name="V" />: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> for uniform data <paramref name="V" /> (as specified by <paramref name="X" />)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X" /> to the unit interval [0,1] and applying the new positions to
            the surrounding two hypercubes in each dimension of <paramref name="V" />. The algorithm is optimized
            for large data <paramref name="V" /> and fine <paramref name="Xn" /> grids. Fastest results are obtained when many new query points are to be computed per hypercube
            in <paramref name="V" /> and if these points are arranged along the first dimension of <paramref name="V" />. I.e: when a significant large range was provided in <paramref name="Xn" />[0].</para><para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para><para>On non-uniform data <paramref name="V" /> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />.
            </para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid.
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of <paramref name="V" />) with <i>strictly
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V" />. The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />, the grid of new values is
            always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for
            the corresponding dimension in <paramref name="V" />, the ranges for the new values in the corresponding dimension to be returned are computed by
            refining the existing range from <paramref name="X" />. Every grid cell determined by <paramref name="X" /> is therefore split into half, roughly
            doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> offers.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex})" />. Good performance is achieved via
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional gridded cubic spline interpolation from sampled grids.
            </summary>
            <param name="V">Sampled values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the sample range (<paramref name="X" />). Null: extrapolate.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: <see cref="T:ILNumerics.Array`1" /> corresponding to element type of <paramref name="V" />) with the <i>strictly monotonically increasing</i> range specification
            for the corresponding dimension in <paramref name="V" />. The spacing between elements within each dimension must not be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="Xn" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual
            arrays in the cell <paramref name="Xn" /> form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />,
            the grid of new values is always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for the corresponding dimension in <paramref name="V" />,
            the ranges for the new values in the corresponding dimension to be returned are computed by refining the existing range from <paramref name="X" />. Every grid cell determined
            by <paramref name="X" /> is therefore split into half, roughly doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />.</para><para>Algorithm for uniform <paramref name="V" />: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> for uniform data <paramref name="V" /> (as specified by <paramref name="X" />)
            implements standard Catmull-Rom splines by scaling the axis ranges given by <paramref name="X" /> to the unit interval [0,1] and applying the new positions to
            the surrounding two hypercubes in each dimension of <paramref name="V" />. The algorithm is optimized
            for large data <paramref name="V" /> and fine <paramref name="Xn" /> grids. Fastest results are obtained when many new query points are to be computed per hypercube
            in <paramref name="V" /> and if these points are arranged along the first dimension of <paramref name="V" />. I.e: when a significant large range was provided in <paramref name="Xn" />[0].</para><para>The algorithm is parallelized for multicore systems. The implementation commonly outperforms competitive algorithms of similar CAS by factors.</para><para>On non-uniform data <paramref name="V" /> the new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />.
            </para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional cubic spline interpolation for gridded points from a given data grid.
            </summary>
            <param name="V">Known values, N-dimensional array, at least 4 elements in each dimension are required.</param>
            <param name="X">[Optional] Sample grid position vectors (non-/uniform) for the axes of <paramref name="V" />. Cell array of lenght N. Default: (null) auto spacing from 0, step 1.</param>
            <param name="Xn">[Optional] Interpolation grid vectors (non-/uniform). Cell array of length N. Default (null): create query grid by refining <paramref name="X" /> once.</param>
            <returns>Spline interpolated values according to the n-dimensional range given in <paramref name="Xn" />.</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation on a n-dimensional
            <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with [<c>V.S.NumberOfDimensions</c>] arrays
            as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of <paramref name="V" />) with <i>strictly
            monotonically increasing</i> range specifications for the corresponding dimension in <paramref name="V" />. The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            form a grid of the same dimensionality as <paramref name="V" />. Therefore and similarily to <paramref name="X" />, the grid of new values is
            always <i>regular</i> but <i>not</i> necessarily uniform.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>If <paramref name="Xn" /> is not provided (i.e.: is <c>null</c>) or for any cell element in <paramref name="Xn" /> being not provided for
            the corresponding dimension in <paramref name="V" />, the ranges for the new values in the corresponding dimension to be returned are computed by
            refining the existing range from <paramref name="X" />. Every grid cell determined by <paramref name="X" /> is therefore split into half, roughly
            doubling the resolution for the resulting range.</para><para>Any of <paramref name="X" /> and <paramref name="Xn" /> inputs are allowed to provide not only vectors but n-dimensional arrays as
            the result of functions like <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />.
            In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, for example, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> offers.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: The new query points are computed by efficient, subsequent one-dimensional spline interpolations via
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />. Good performance is achieved via
            efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>References: "Two hierarchies of spline interpolations. Practical algorithms for multivariate higher order splines." Cristian Constantin Lalescu, May 21, 2009.</para><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /><seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" /></remarks>
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked with the value given in <paramref name="outofRangeValues" />.
            Use <c>null</c> to get extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked as 'NaN'
            values. Use the overload <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)" /> to control this value or to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)" />
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex},ILNumerics.OutArray{ILNumerics.complex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked with
            the value given in <paramref name="outofRangeValues" />. Use <c>null</c> for <paramref name="outofRangeValues" /> to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="!:splinens(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?)" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.complex})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;complex&gt;, InCell, InArray&lt;complex&gt;, complex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)" />
            <seealso cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked with the value given in <paramref name="outofRangeValues" />.
            Use <c>null</c> to get extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked as 'NaN'
            values. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})" /> to control this value or to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single},ILNumerics.OutArray{System.Single})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked with
            the value given in <paramref name="outofRangeValues" />. Use <c>null</c> for <paramref name="outofRangeValues" /> to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single})" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Single})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked with the value given in <paramref name="outofRangeValues" />.
            Use <c>null</c> to get extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked as 'NaN'
            values. Use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})" /> to control this value or to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double},ILNumerics.OutArray{System.Double})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked with
            the value given in <paramref name="outofRangeValues" />. Use <c>null</c> for <paramref name="outofRangeValues" /> to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double})" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{System.Double})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked as NaN. Use the 2nd non-optional parameter from the overload
            <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})" /> in order to control this value or to get extrapolated values instead.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Sample grid position vectors (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), each of length m. Cell array of length N.</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. Null: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the grid vectors <paramref name="Xn" />. Individual arrays in the cell <paramref name="Xn" />
            contain the coordinates of the new query points for each dimension of V. Therefore, all cell element arrays in <paramref name="Xn" /> must expose
            the same number of elements: <c>m</c>.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> are marked with the value given in <paramref name="outofRangeValues" />.
            Use <c>null</c> to get extrapolated values at those positions.</para><para>Algorithm: <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs one-dimensional interpolation of the spline <i>coefficients</i> along all n
            dimensions. The resulting coefficients hyper cube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />.</para><para>A note on efficiency: for large <paramref name="Xn" /> is could be more efficient to use the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})" /> since
            this will be called anyway. Hence, if your <paramref name="Xn" /> data exists in matrix form, consider using the matching overload instead.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked as 'NaN'
            values. Use the overload <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)" /> to control this value or to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)" />
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex})">
            <summary>
            N-dimensional spline interpolation of scattered data from gridded points.
            </summary>
            <param name="V">Known values as n-dimensional array, at least 4 samples in each dimension.</param>
            <param name="X">Grid position vectors for the values in V (non-/uniform), matching the lengths of corresponding dims in <paramref name="V" />. Cell array of length N.</param>
            <param name="Xn">Interpolation grid vectors (non-/uniform), matrix of size [n x m].</param>
            <param name="outofRangeValues">Scalar value for all result elements which lay outside of the given domain <paramref name="V" />. <c>null</c>: extrapolate.</param>
            <returns>Spline interpolated values at scattered positions as determined by <paramref name="Xn" />. Size [1 x m].</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> performs efficient piecewise cubic interpolation with continous 2nd derivatives
            on an n-dimensional <i>regular</i> grid of sampled values <paramref name="V" />. <paramref name="X" /> is expected as a cell vector with
            [<c>V.S.NumberOfDimensions</c>] arrays as cell elements. Each element is a numeric array (preferred: Array&lt;T&gt; corresponding to element type T of
            <paramref name="V" />) with <i>strictly monotonically increasing</i> range specifications for the corresponding dimensions in <paramref name="V" />.
            The spacing between elements must <i>not</i> be uniform.</para><para>The spline interpolation function created by <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> will always match the
            given data values <paramref name="V" /> at the specified sample positions <paramref name="X" />.</para><para>New values to be interpolated are specified by the columns in <paramref name="Xn" />.</para><para>Any range for <paramref name="V" /> not provided in <paramref name="X" /> (i.e. the corresponding cell element <c>X_i</c> is null or empty) is automatically replaced by
            an upwards counting vector: <c>counter(0,1,size(l,1))</c>, where <c>l=V.S[i]</c>. If the parameter <paramref name="X" /> is null on entry, the
            same scheme applies to all dimensions of <paramref name="V" />.</para><para>Note, that in difference to <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)" /> both, <paramref name="X" /> and <paramref name="Xn" /> are obligatory parameters!
            <paramref name="Xn" /> is not allowed to be null on entry.</para><para><paramref name="X" /> is allowed to hold not only vectors but n-dimensional arrays as the result of the <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" />
            function. In this case, only the first 'vector' along each corresponding dimension is considered from the input arrays. If, let's say, a matrix is given for the first
            cell element in <paramref name="X" /> the first column is extracted and its values are assumed for the ranges of the first dimension in <paramref name="V" />. Note that
            all n-dimensional functions expect the common order of dimensions: 1st dimension goes along the columns, 2nd dimension goes along the rows. This (intentionally) differs
            from the somehow mixed-up way <see cref="M:ILNumerics.Core.Functions.Builtin.MathInternal.meshgrid(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex},ILNumerics.OutArray{ILNumerics.fcomplex})" /> shows.</para><para>Any values from <paramref name="Xn" /> laying <b>outside of the range</b> of <paramref name="X" /> will cause the corresponding result elements to be marked with
            the value given in <paramref name="outofRangeValues" />. Use <c>null</c> for <paramref name="outofRangeValues" /> to compute extrapolated values at those positions.</para><para>Algorithm: <see cref="!:splinens(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?)" /> performs one-dimensional interpolation of the spline <i>coefficients</i>
            along all n dimensions. The resulting coefficients hypercube is then used to perform a fast and parallelized variant of local cubic evaluation of the surrounding hypercubes for
            each query point. Good performance is achieved via efficient parallelization in the underlying <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" /> object. However, the interpolation
            of the coefficients in n dimensions require a significant amount of memory: roughly 4 times the original dimension length is required for each dimension. Therefore, on
            larger data one might consider to use <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpns(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" /> with <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.cubic" />
            instead.</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="V" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="V" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="V" />. Use cubic polynomial interpolation in <see cref="!:Interpolation.interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, InterpolationMethod)" />
            for an alternative on data with NaN values.</para><para>This n-dimensional spline interpolation is called from <see cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />.</para><para>A note on convenience: if the coordinates for new query points exist as individual vectors anyway, consider using the overload <see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,System.Nullable{ILNumerics.fcomplex})" />.</para><para>References: C. de Boor, A Practical Guide to Splines (Applied Mathematical Sciences), Springer, 2001"</para></remarks>
            <seealso cref="!:interpns(InArray&lt;fcomplex&gt;, InCell, InArray&lt;fcomplex&gt;, fcomplex?, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)" />
            <seealso cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" />
            <exception cref="T:System.ArgumentException">if <paramref name="V" /> has less than 4 elements in any dimension or any range in <paramref name="X" /> does
            not match the corresponding dimension length in <paramref name="V" />.</exception>
            <exception cref="T:System.ArgumentNullException"> if on entry any of <paramref name="V" /> or <paramref name="X" /> are <c>null</c>.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)">
            <summary>
            Create interpolated values for the path through points given by <paramref name="X" /> in R^n.
            </summary>
            <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
            <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution" />] times as many intermediate points as given in <paramref name="X" />.</param>
            <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
            <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
            <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X" />. Default is 20.</param>
            <returns>Matrix with smoothed path through points defined by <paramref name="X" />. Number of rows: X.S[0], number of columns: Xn.Length</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32)" /> creates a smooth path connecting the points
            defined by the columns of <paramref name="X" />. Cubic spline interpolation is used to create intermediate points within individual seqments between the original
            points. The matrix returned can be directly used for rendering purposes.</para><para><paramref name="X" /> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X" />
            defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para><para>The parameter <paramref name="Xn" /> allows to control the number and position of intermediate points. The function expects a vector with
            values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X" />). 1 corresponds to the end of
            the path at the last point in <paramref name="X" />. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn" /> is
            null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values
            are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X" />.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> are used to specify the 1st order derivative at the lower and
            upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end
            point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv" /> and/or <paramref name="ubDeriv" /> the corresponding
            end of the path will be computed as having that value as <i>first derivative</i> (slope).</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="X" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para><code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
            // create 21 random points in 3d space
            Array</*!HC:inArr1*/ double> Points = rand(3, 21);
            
            // setup the plot cube ...
            ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
            // ... render original points as markers (line color: "empty" hides the line of the line plot)
            new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
            });
            
            // setup labels next to the points
            for (int i = 0; i < Points.S[1]; i++) {
            // position for the label
            Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i));
            // add new label
            ilPanel1.Scene.First<PlotCube>().Add(
            new Label(i.ToString() + " ") {
            Position = pos,
            // create some margin
            Anchor = new PointF(1.5f,.5f)
            });
            }
            // generate spline interpolated values for a smoothed path through the points
            Array</*!HC:inArr1*/ double> spl = spline(Points);
            // draw the path as regular line plot
            ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Toolboxes.Interpolation" />
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinepath(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Int32)">
            <summary>
            Create interpolated values for the path through points given by <paramref name="X" /> in R^n.
            </summary>
            <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
            <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution" />] times as many intermediate points as given in <paramref name="X" />.</param>
            <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
            <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
            <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X" />. Default is 20.</param>
            <returns>Matrix with smoothed path through points defined by <paramref name="X" />. Number of rows: X.S[0], number of columns: Xn.Length</returns>
            <remarks><para><see cref="!:splinepath(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int)" /> creates a smooth path connecting the points
            defined by the columns of <paramref name="X" />. Cubic spline interpolation is used to create intermediate points within individual seqments between the original
            points. The matrix returned can be directly used for rendering purposes.</para><para><paramref name="X" /> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X" />
            defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para><para>The parameter <paramref name="Xn" /> allows to control the number and position of intermediate points. The function expects a vector with
            values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X" />). 1 corresponds to the end of
            the path at the last point in <paramref name="X" />. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn" /> is
            null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values
            are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X" />.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> are used to specify the 1st order derivative at the lower and
            upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end
            point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv" /> and/or <paramref name="ubDeriv" /> the corresponding
            end of the path will be computed as having that value as <i>first derivative</i> (slope).</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="X" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para><code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
            // create 21 random points in 3d space
            Array< complex> Points = rand(3, 21);
            
            // setup the plot cube ...
            ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
            // ... render original points as markers (line color: "empty" hides the line of the line plot)
            new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
            });
            
            // setup labels next to the points
            for (int i = 0; i < Points.S[1]; i++) {
            // position for the label
            Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i));
            // add new label
            ilPanel1.Scene.First<PlotCube>().Add(
            new Label(i.ToString() + " ") {
            Position = pos,
            // create some margin
            Anchor = new PointF(1.5f,.5f)
            });
            }
            // generate spline interpolated values for a smoothed path through the points
            Array< complex> spl = spline(Points);
            // draw the path as regular line plot
            ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Toolboxes.Interpolation" />
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorComplex" />
            <seealso cref="!:spline(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="!:interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinepath(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Create interpolated values for the path through points given by <paramref name="X" /> in R^n.
            </summary>
            <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
            <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution" />] times as many intermediate points as given in <paramref name="X" />.</param>
            <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
            <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
            <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X" />. Default is 20.</param>
            <returns>Matrix with smoothed path through points defined by <paramref name="X" />. Number of rows: X.S[0], number of columns: Xn.Length</returns>
            <remarks><para><see cref="!:splinepath(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int)" /> creates a smooth path connecting the points
            defined by the columns of <paramref name="X" />. Cubic spline interpolation is used to create intermediate points within individual seqments between the original
            points. The matrix returned can be directly used for rendering purposes.</para><para><paramref name="X" /> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X" />
            defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para><para>The parameter <paramref name="Xn" /> allows to control the number and position of intermediate points. The function expects a vector with
            values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X" />). 1 corresponds to the end of
            the path at the last point in <paramref name="X" />. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn" /> is
            null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values
            are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X" />.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> are used to specify the 1st order derivative at the lower and
            upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end
            point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv" /> and/or <paramref name="ubDeriv" /> the corresponding
            end of the path will be computed as having that value as <i>first derivative</i> (slope).</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="X" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para><code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
            // create 21 random points in 3d space
            Array< fcomplex> Points = rand(3, 21);
            
            // setup the plot cube ...
            ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
            // ... render original points as markers (line color: "empty" hides the line of the line plot)
            new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
            });
            
            // setup labels next to the points
            for (int i = 0; i < Points.S[1]; i++) {
            // position for the label
            Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i));
            // add new label
            ilPanel1.Scene.First<PlotCube>().Add(
            new Label(i.ToString() + " ") {
            Position = pos,
            // create some margin
            Anchor = new PointF(1.5f,.5f)
            });
            }
            // generate spline interpolated values for a smoothed path through the points
            Array< fcomplex> spl = spline(Points);
            // draw the path as regular line plot
            ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Toolboxes.Interpolation" />
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex" />
            <seealso cref="!:spline(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="!:interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="M:ILNumerics.Toolboxes.Interpolation.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)">
            <summary>
            Create interpolated values for the path through points given by <paramref name="X" /> in R^n.
            </summary>
            <param name="X">Matrix with points in columns. Any dimensionality (number of rows) is accepted.</param>
            <param name="Xn">[Optional] fractional positions to evaluate the spline for. Default (null): create [<paramref name="resolution" />] times as many intermediate points as given in <paramref name="X" />.</param>
            <param name="lbDeriv">[Optional] start boundary condition. Default: null (not-a-knot spline)</param>
            <param name="ubDeriv">[Optional] end boundary condition. Default: null (not-a-knot spline)</param>
            <param name="resolution">[Optional] resolution factor for new query points to produce, times number of original values in <paramref name="X" />. Default is 20.</param>
            <returns>Matrix with smoothed path through points defined by <paramref name="X" />. Number of rows: X.S[0], number of columns: Xn.Length</returns>
            <remarks><para><see cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinepath(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32)" /> creates a smooth path connecting the points
            defined by the columns of <paramref name="X" />. Cubic spline interpolation is used to create intermediate points within individual seqments between the original
            points. The matrix returned can be directly used for rendering purposes.</para><para><paramref name="X" /> defines the original points as columns of the input matrix. The points are defined in R^n: any number of rows are allowed. Typically, <paramref name="X" />
            defines points in 2D or 3D space, resulting in a path (curve) in 2D or 3D (hypercurve). However, higher dimensionalities are supported as well.</para><para>The parameter <paramref name="Xn" /> allows to control the number and position of intermediate points. The function expects a vector with
            values in range 0...1. Position 0 corresponds to the beginning of the path (first column of <paramref name="X" />). 1 corresponds to the end of
            the path at the last point in <paramref name="X" />. Values outside of that range cause extrapolated values to be computed and returned. If <paramref name="Xn" /> is
            null (default) the number and positions of intermediate values are determined automatically. In this case, m intermediate equally spaced values
            are created along the path, where m = 20 x X.S[1], the number of original seqments given in <paramref name="X" />.</para><para>The parameters <paramref name="lbDeriv" /> and <paramref name="ubDeriv" /> are used to specify the 1st order derivative at the lower and
            upper bound (start and end of the curve). Leaving these parameters undefined (null) creates a <i>not-a-knot</i> cubic spline: the slope of the path at the end
            point is derived from the slope of the surrounding samples (3rd derivative = 0). If values are given for either <paramref name="lbDeriv" /> and/or <paramref name="ubDeriv" /> the corresponding
            end of the path will be computed as having that value as <i>first derivative</i> (slope).</para><para><strong>Support for NaN values:</strong> spline interpolation performs interpolation by taking all values of
            <paramref name="X" /> into account. What enables best smoothness properties on the other hand implies that <strong>any</strong> NaN value in <paramref name="X" />
            populate to all elements of the output. Therefore, one must ensure that no NaN values exist in <paramref name="X" />. Use cubic polynomial interpolation in <see cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
            for an alternative on data with NaN values.</para></remarks>
            <example><para>Creates and plots a smooth path through 21 random data points. Use this example in a Windows Forms Application project.</para><code><![CDATA[private void ilPanel1_Load(object sender, EventArgs e) {
            // create 21 random points in 3d space
            Array< float> Points = rand(3, 21);
            
            // setup the plot cube ...
            ilPanel1.Scene.Add(new PlotCube(twoDMode: false) {
            // ... render original points as markers (line color: "empty" hides the line of the line plot)
            new LinePlot(tosingle(Points), lineColor: Color.Empty, markerStyle: MarkerStyle.Dot)
            });
            
            // setup labels next to the points
            for (int i = 0; i < Points.S[1]; i++) {
            // position for the label
            Vector3 pos = new Vector3(Points.GetValue(0,i), Points.GetValue(1,i), Points.GetValue(2,i));
            // add new label
            ilPanel1.Scene.First<PlotCube>().Add(
            new Label(i.ToString() + " ") {
            Position = pos,
            // create some margin
            Anchor = new PointF(1.5f,.5f)
            });
            }
            // generate spline interpolated values for a smoothed path through the points
            Array< float> spl = spline(Points);
            // draw the path as regular line plot
            ilPanel1.Scene.First<PlotCube>().Add(new LinePlot(tosingle(spl)));
            }
            ]]></code></example>
            <seealso cref="T:ILNumerics.Toolboxes.Interpolation" />
            <seealso cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.spline(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.splinen(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interp2(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)" />
            <seealso cref="M:ILNumerics.Toolboxes.InterpolationInternal.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)" />
        </member>
        <member name="T:ILNumerics.Toolboxes.CubicInterpolatorDouble">
            <summary>
            CubicInterpolator class provides 1D interpolation using Cubic Interpolation function.
            </summary>      
        </member>
        <member name="F:ILNumerics.Toolboxes.CubicInterpolatorDouble.m_Vdims">
            <summary>
            The original size of V as it was provided by the user; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
             <summary>
             Creates a cubic interpolator object, using specified values in <paramref name="V"/> at positions in <paramref name="X"/>.
             </summary>
             <param name="V">Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln-1].</param>
             <param name="X">Strictly monotonically increasing coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to interpolation results 
             outside of the range specified by <paramref name="X"/>. Default: (null) value outside of the <paramref name="X"/> range are extrapolated.</param>        
             <remarks><para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorDouble"/> prepares a 1-dimensional, cubic interpolator object, 
             for the given set of <b>m</b> measured values. The new interpolator can be used to compute multiple new interpolated values efficiently. 
             See: <see cref="M:ILNumerics.Toolboxes.CubicInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/>.</para>
             <para>If <paramref name="V"/> is a matrix or a n-dimensional array the columns of <paramref name="V"/> are considered n individual sets of 
             measurements, all providing individual values at the same coordinates <paramref name="X"/>. Each element requested in <see cref="M:ILNumerics.Toolboxes.CubicInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/> 
             will be interpolated regarding all respective columns of <paramref name="V"/>. In this case <c>n</c> becomes: V.S.NumberOfElements / m, with <c>m=V.S[0]</c>.</para>
             <para>Alternatively, <paramref name="V"/> can be defined as vector (row or column vector) of length <b>m</b>.</para>
             <para>After all values have been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             </remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new CubicInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If <paramref name="X"/>/ <paramref name="V"/> have less than 4 elements, if 
             values in <paramref name="X"/> are not strictly monotonically increasing, if <paramref name="X"/> 
             or <paramref name="V"/> have more than 2 dimensions, or if the number of elements in <paramref name="X"/>
             does not match the length of the working dimension in <paramref name="V"/>.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>       
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             Computes interpolated values using this cubic interpolator for new query points <paramref name="Xn"/>.
             </summary>
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. 
             The shape of <paramref name="Xn"/> is not taken into account. Values of <paramref name="Xn"/> are read in sequential, 
             column-major order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator object. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements.
             The 'working dimension' index of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new CubicInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorDouble.Dispose">
            <summary>
            Dispose this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.CubicInterpolatorComplex">
            <summary>
            CubicInterpolator class provides 1D interpolation using Cubic Interpolation function.
            </summary>      
        </member>
        <member name="F:ILNumerics.Toolboxes.CubicInterpolatorComplex.m_Vdims">
            <summary>
            The original size of V as it was provided by the user; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex})">
             <summary>
             Creates a cubic interpolator object, using specified values in <paramref name="V"/> at positions in <paramref name="X"/>.
             </summary>
             <param name="V">Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln-1].</param>
             <param name="X">Strictly monotonically increasing coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to interpolation results 
             outside of the range specified by <paramref name="X"/>. Default: (null) value outside of the <paramref name="X"/> range are extrapolated.</param>        
             <remarks><para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorDouble"/> prepares a 1-dimensional, cubic interpolator object, 
             for the given set of <b>m</b> measured values. The new interpolator can be used to compute multiple new interpolated values efficiently. 
             See: <see cref="!:Apply(InArray&lt;complex&gt;, InCell)"/>.</para>
             <para>If <paramref name="V"/> is a matrix or a n-dimensional array the columns of <paramref name="V"/> are considered n individual sets of 
             measurements, all providing individual values at the same coordinates <paramref name="X"/>. Each element requested in <see cref="!:Apply(InArray&lt;complex&gt;, InCell)"/> 
             will be interpolated regarding all respective columns of <paramref name="V"/>. In this case <c>n</c> becomes: V.S.NumberOfElements / m, with <c>m=V.S[0]</c>.</para>
             <para>Alternatively, <paramref name="V"/> can be defined as vector (row or column vector) of length <b>m</b>.</para>
             <para>After all values have been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             </remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new CubicInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If <paramref name="X"/>/ <paramref name="V"/> have less than 4 elements, if 
             values in <paramref name="X"/> are not strictly monotonically increasing, if <paramref name="X"/> 
             or <paramref name="V"/> have more than 2 dimensions, or if the number of elements in <paramref name="X"/>
             does not match the length of the working dimension in <paramref name="V"/>.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>       
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             Computes interpolated values using this cubic interpolator for new query points <paramref name="Xn"/>.
             </summary>
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. 
             The shape of <paramref name="Xn"/> is not taken into account. Values of <paramref name="Xn"/> are read in sequential, 
             column-major order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator object. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements.
             The 'working dimension' index of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new CubicInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorComplex.Dispose">
            <summary>
            Dispose this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.CubicInterpolatorFComplex">
            <summary>
            CubicInterpolator class provides 1D interpolation using Cubic Interpolation function.
            </summary>      
        </member>
        <member name="F:ILNumerics.Toolboxes.CubicInterpolatorFComplex.m_Vdims">
            <summary>
            The original size of V as it was provided by the user; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex})">
             <summary>
             Creates a cubic interpolator object, using specified values in <paramref name="V"/> at positions in <paramref name="X"/>.
             </summary>
             <param name="V">Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln-1].</param>
             <param name="X">Strictly monotonically increasing coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to interpolation results 
             outside of the range specified by <paramref name="X"/>. Default: (null) value outside of the <paramref name="X"/> range are extrapolated.</param>        
             <remarks><para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorSingle"/> prepares a 1-dimensional, cubic interpolator object, 
             for the given set of <b>m</b> measured values. The new interpolator can be used to compute multiple new interpolated values efficiently. 
             See: <see cref="!:Apply(InArray&lt;fcomplex&gt;, InCell)"/>.</para>
             <para>If <paramref name="V"/> is a matrix or a n-dimensional array the columns of <paramref name="V"/> are considered n individual sets of 
             measurements, all providing individual values at the same coordinates <paramref name="X"/>. Each element requested in <see cref="!:Apply(InArray&lt;fcomplex&gt;, InCell)"/> 
             will be interpolated regarding all respective columns of <paramref name="V"/>. In this case <c>n</c> becomes: V.S.NumberOfElements / m, with <c>m=V.S[0]</c>.</para>
             <para>Alternatively, <paramref name="V"/> can be defined as vector (row or column vector) of length <b>m</b>.</para>
             <para>After all values have been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             </remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new CubicInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If <paramref name="X"/>/ <paramref name="V"/> have less than 4 elements, if 
             values in <paramref name="X"/> are not strictly monotonically increasing, if <paramref name="X"/> 
             or <paramref name="V"/> have more than 2 dimensions, or if the number of elements in <paramref name="X"/>
             does not match the length of the working dimension in <paramref name="V"/>.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>       
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             Computes interpolated values using this cubic interpolator for new query points <paramref name="Xn"/>.
             </summary>
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. 
             The shape of <paramref name="Xn"/> is not taken into account. Values of <paramref name="Xn"/> are read in sequential, 
             column-major order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator object. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements.
             The 'working dimension' index of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new CubicInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorFComplex.Dispose">
            <summary>
            Dispose this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.CubicInterpolatorSingle">
            <summary>
            CubicInterpolator class provides 1D interpolation using Cubic Interpolation function.
            </summary>      
        </member>
        <member name="F:ILNumerics.Toolboxes.CubicInterpolatorSingle.m_Vdims">
            <summary>
            The original size of V as it was provided by the user; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
             <summary>
             Creates a cubic interpolator object, using specified values in <paramref name="V"/> at positions in <paramref name="X"/>.
             </summary>
             <param name="V">Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln-1].</param>
             <param name="X">Strictly monotonically increasing coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to interpolation results 
             outside of the range specified by <paramref name="X"/>. Default: (null) value outside of the <paramref name="X"/> range are extrapolated.</param>        
             <remarks><para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorSingle"/> prepares a 1-dimensional, cubic interpolator object, 
             for the given set of <b>m</b> measured values. The new interpolator can be used to compute multiple new interpolated values efficiently. 
             See: <see cref="M:ILNumerics.Toolboxes.CubicInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/>.</para>
             <para>If <paramref name="V"/> is a matrix or a n-dimensional array the columns of <paramref name="V"/> are considered n individual sets of 
             measurements, all providing individual values at the same coordinates <paramref name="X"/>. Each element requested in <see cref="M:ILNumerics.Toolboxes.CubicInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/> 
             will be interpolated regarding all respective columns of <paramref name="V"/>. In this case <c>n</c> becomes: V.S.NumberOfElements / m, with <c>m=V.S[0]</c>.</para>
             <para>Alternatively, <paramref name="V"/> can be defined as vector (row or column vector) of length <b>m</b>.</para>
             <para>After all values have been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.CubicInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             </remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new CubicInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If <paramref name="X"/>/ <paramref name="V"/> have less than 4 elements, if 
             values in <paramref name="X"/> are not strictly monotonically increasing, if <paramref name="X"/> 
             or <paramref name="V"/> have more than 2 dimensions, or if the number of elements in <paramref name="X"/>
             does not match the length of the working dimension in <paramref name="V"/>.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>       
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             Computes interpolated values using this cubic interpolator for new query points <paramref name="Xn"/>.
             </summary>
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. 
             The shape of <paramref name="Xn"/> is not taken into account. Values of <paramref name="Xn"/> are read in sequential, 
             column-major order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator object. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements.
             The 'working dimension' index of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new CubicInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.CubicInterpolatorSingle.Dispose">
            <summary>
            Dispose this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.KrigingInterpolatorDouble">
            <summary>
            KrigingInterpolator Class
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInv">
            <summary>
            The covariance computed from the source values. A columns and rows except the last one, respectively.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvLastRow">
            <summary>
            The last row of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvLastCol">
            <summary>
            The last column of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvEndEnd">
            <summary>
            The last data point of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInv"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvByYwoLastVal">
            <summary>
            Covariance inverted and multiplied by <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_Y"/>, w/o the last value(s). 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvByYLastVal">
            <summary>
            Last value of the data stored in <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_covInvByYwoLastVal"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_Y">
            <summary>
            The source data used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_X">
            <summary>
            The source coordinates used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_variogram">
            <summary>
            Variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_powerLawAlpha">
            <summary>
            Alpha value computed for the (default) power law variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorDouble.m_powerLawBeta">
            <summary>
            The beta value for the (defaul) variogramm function (power law). Default: 1.5.
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawAlpha">
            <summary>
            Alpha value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawBeta"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.X">
            <summary>
            The original points data this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Y">
            <summary>
            The original point values this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawBeta">
            <summary>
            Beta value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances. 
            Possible values are in the range 1 &lt;= <paramref name="value"/> &lt; 2.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawAlpha"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dim">
            <summary>
            The number of dimensions of the sample points this interpolator is based upon [readonly]. New query points must conform to this dimensionality. 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})">
            <summary>
            Simple power-law variogram function, used as default variogram for kriging interpolation
            </summary>
            <param name="Distances">Symmetric matrix with euclidian distances of the provided datapoints.</param>
            <returns>Variogram weights for the <paramref name="Distances"/> provided.</returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.InArray{System.Double},System.Boolean)">
            <summary>
            Create a Kriging interpolator
            </summary>
            <param name="Y">Data values, matrix with measured values at the n data points specified by <paramref name="X"/>. Size [k x n].</param>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="errors">[Optional] (this paramter is currently ignored)</param>
            <param name="doChecks">[Optional] True: check the distances between points provided in <paramref name="X"/> for too small values (default). False: do not perform these checks (and save some computations).</param>
            <remarks><para>The optional parameter <paramref name="doChecks"/> is used to prevent the kriging interpolator from instability effects caused by disadvantageous positions <paramref name="X"/>. If points in 
            <paramref name="X"/> are too close to each other, the resulting distance matrix (and its inversion later on) might cause singularity problems. Therefore and if <paramref name="doChecks"/> is <c>true</c> 
            checks are automatically made for that and potential redundant values are removed from the data set.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="Y"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="errors"/> is not null but also not a vector of lenght <c>X.S[1]</c>.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
            <summary>
            Apply new data points to the interpolator in order to estimate new values for them.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dim"/>.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para>
            <para>The additional input argument <paramref name="arguments"/> is currently ignored.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Compute interpolated values and optionally compute confidence estimates for new data points.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dim"/>.</param>
            <param name="errors">[Optional] if none-null on entry confidence estimates (error estimates) are computed for the positions in <paramref name="X"/>.</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Dispose">
            <summary>
            Dispose this object and all resources stored inside it after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.KrigingInterpolatorComplex">
            <summary>
            KrigingInterpolator Class
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInv">
            <summary>
            The covariance computed from the source values. A columns and rows except the last one, respectively.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvLastRow">
            <summary>
            The last row of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvLastCol">
            <summary>
            The last column of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvEndEnd">
            <summary>
            The last data point of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInv"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvByYwoLastVal">
            <summary>
            Covariance inverted and multiplied by <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_Y"/>, w/o the last value(s). 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvByYLastVal">
            <summary>
            Last value of the data stored in <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_covInvByYwoLastVal"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_Y">
            <summary>
            The source data used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_X">
            <summary>
            The source coordinates used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_variogram">
            <summary>
            Variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_powerLawAlpha">
            <summary>
            Alpha value computed for the (default) power law variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorComplex.m_powerLawBeta">
            <summary>
            The beta value for the (defaul) variogramm function (power law). Default: 1.5.
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawAlpha">
            <summary>
            Alpha value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawVariogram(ILNumerics.InArray{System.Double})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawBeta"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.X">
            <summary>
            The original points data this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Y">
            <summary>
            The original point values this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawBeta">
            <summary>
            Beta value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances. 
            Possible values are in the range 1 &lt;= <paramref name="value"/> &lt; 2.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawVariogram(ILNumerics.InArray{System.Double})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawAlpha"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dim">
            <summary>
            The number of dimensions of the sample points this interpolator is based upon [readonly]. New query points must conform to this dimensionality. 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawVariogram(ILNumerics.InArray{System.Double})">
            <summary>
            Simple power-law variogram function, used as default variogram for kriging interpolation
            </summary>
            <param name="Distances">Symmetric matrix with euclidian distances of the provided datapoints.</param>
            <returns>Variogram weights for the <paramref name="Distances"/> provided.</returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Func{ILNumerics.InArray{System.Double},ILNumerics.RetArray{System.Double}},ILNumerics.InArray{System.Double},System.Boolean)">
            <summary>
            Create a Kriging interpolator
            </summary>
            <param name="Y">Data values, matrix with measured values at the n data points specified by <paramref name="X"/>. Size [k x n].</param>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.PowerLawVariogram(ILNumerics.InArray{System.Double})"/></param>
            <param name="errors">[Optional] (this paramter is currently ignored)</param>
            <param name="doChecks">[Optional] True: check the distances between points provided in <paramref name="X"/> for too small values (default). False: do not perform these checks (and save some computations).</param>
            <remarks><para>The optional parameter <paramref name="doChecks"/> is used to prevent the kriging interpolator from instability effects caused by disadvantageous positions <paramref name="X"/>. If points in 
            <paramref name="X"/> are too close to each other, the resulting distance matrix (and its inversion later on) might cause singularity problems. Therefore and if <paramref name="doChecks"/> is <c>true</c> 
            checks are automatically made for that and potential redundant values are removed from the data set.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="Y"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="errors"/> is not null but also not a vector of lenght <c>X.S[1]</c>.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
            <summary>
            Apply new data points to the interpolator in order to estimate new values for them.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dim"/>.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para>
            <para>The additional input argument <paramref name="arguments"/> is currently ignored.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.OutArray{System.Double})">
            <summary>
            Compute interpolated values and optionally compute confidence estimates for new data points.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dim"/>.</param>
            <param name="errors">[Optional] if none-null on entry confidence estimates (error estimates) are computed for the positions in <paramref name="X"/>.</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorComplex.Dispose">
            <summary>
            Dispose this object and all resources stored inside it after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.KrigingInterpolatorFComplex">
            <summary>
            KrigingInterpolator Class
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInv">
            <summary>
            The covariance computed from the source values. A columns and rows except the last one, respectively.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvLastRow">
            <summary>
            The last row of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvLastCol">
            <summary>
            The last column of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvEndEnd">
            <summary>
            The last data point of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInv"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvByYwoLastVal">
            <summary>
            Covariance inverted and multiplied by <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_Y"/>, w/o the last value(s). 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvByYLastVal">
            <summary>
            Last value of the data stored in <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_covInvByYwoLastVal"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_Y">
            <summary>
            The source data used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_X">
            <summary>
            The source coordinates used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_variogram">
            <summary>
            Variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_powerLawAlpha">
            <summary>
            Alpha value computed for the (default) power law variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.m_powerLawBeta">
            <summary>
            The beta value for the (defaul) variogramm function (power law). Default: 1.5.
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawAlpha">
            <summary>
            Alpha value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawVariogram(ILNumerics.InArray{System.Single})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawBeta"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.X">
            <summary>
            The original points data this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Y">
            <summary>
            The original point values this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawBeta">
            <summary>
            Beta value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances. 
            Possible values are in the range 1 &lt;= <paramref name="value"/> &lt; 2.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawVariogram(ILNumerics.InArray{System.Single})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawAlpha"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dim">
            <summary>
            The number of dimensions of the sample points this interpolator is based upon [readonly]. New query points must conform to this dimensionality. 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawVariogram(ILNumerics.InArray{System.Single})">
            <summary>
            Simple power-law variogram function, used as default variogram for kriging interpolation
            </summary>
            <param name="Distances">Symmetric matrix with euclidian distances of the provided datapoints.</param>
            <returns>Variogram weights for the <paramref name="Distances"/> provided.</returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.InArray{System.Single},System.Boolean)">
            <summary>
            Create a Kriging interpolator
            </summary>
            <param name="Y">Data values, matrix with measured values at the n data points specified by <paramref name="X"/>. Size [k x n].</param>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.PowerLawVariogram(ILNumerics.InArray{System.Single})"/></param>
            <param name="errors">[Optional] (this paramter is currently ignored)</param>
            <param name="doChecks">[Optional] True: check the distances between points provided in <paramref name="X"/> for too small values (default). False: do not perform these checks (and save some computations).</param>
            <remarks><para>The optional parameter <paramref name="doChecks"/> is used to prevent the kriging interpolator from instability effects caused by disadvantageous positions <paramref name="X"/>. If points in 
            <paramref name="X"/> are too close to each other, the resulting distance matrix (and its inversion later on) might cause singularity problems. Therefore and if <paramref name="doChecks"/> is <c>true</c> 
            checks are automatically made for that and potential redundant values are removed from the data set.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="Y"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="errors"/> is not null but also not a vector of lenght <c>X.S[1]</c>.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
            <summary>
            Apply new data points to the interpolator in order to estimate new values for them.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dim"/>.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para>
            <para>The additional input argument <paramref name="arguments"/> is currently ignored.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Compute interpolated values and optionally compute confidence estimates for new data points.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dim"/>.</param>
            <param name="errors">[Optional] if none-null on entry confidence estimates (error estimates) are computed for the positions in <paramref name="X"/>.</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorFComplex.Dispose">
            <summary>
            Dispose this object and all resources stored inside it after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.KrigingInterpolatorSingle">
            <summary>
            KrigingInterpolator Class
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInv">
            <summary>
            The covariance computed from the source values. A columns and rows except the last one, respectively.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvLastRow">
            <summary>
            The last row of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvLastCol">
            <summary>
            The last column of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInv"/> covariance.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvEndEnd">
            <summary>
            The last data point of the <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInv"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvByYwoLastVal">
            <summary>
            Covariance inverted and multiplied by <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_Y"/>, w/o the last value(s). 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvByYLastVal">
            <summary>
            Last value of the data stored in <see cref="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_covInvByYwoLastVal"/>.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_Y">
            <summary>
            The source data used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_X">
            <summary>
            The source coordinates used to compute this interpolator from. 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_variogram">
            <summary>
            Variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_powerLawAlpha">
            <summary>
            Alpha value computed for the (default) power law variogramm function.
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.KrigingInterpolatorSingle.m_powerLawBeta">
            <summary>
            The beta value for the (defaul) variogramm function (power law). Default: 1.5.
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawAlpha">
            <summary>
            Alpha value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawVariogram(ILNumerics.InArray{System.Single})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawBeta"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.X">
            <summary>
            The original points data this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Y">
            <summary>
            The original point values this interpolator was created for [readonly].
            </summary>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawBeta">
            <summary>
            Beta value for the power law function used as variogram function by default. 
            </summary>
            <remarks>If a custom variogram function was provided, this parameter is ignored. Otherwise one can use it to tune the variogram 
            function of the inter-point distances. 
            Possible values are in the range 1 &lt;= <paramref name="value"/> &lt; 2.</remarks>
            <seealso cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawVariogram(ILNumerics.InArray{System.Single})"/>
            <seealso cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawAlpha"/>
        </member>
        <member name="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dim">
            <summary>
            The number of dimensions of the sample points this interpolator is based upon [readonly]. New query points must conform to this dimensionality. 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawVariogram(ILNumerics.InArray{System.Single})">
            <summary>
            Simple power-law variogram function, used as default variogram for kriging interpolation
            </summary>
            <param name="Distances">Symmetric matrix with euclidian distances of the provided datapoints.</param>
            <returns>Variogram weights for the <paramref name="Distances"/> provided.</returns>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Func{ILNumerics.InArray{System.Single},ILNumerics.RetArray{System.Single}},ILNumerics.InArray{System.Single},System.Boolean)">
            <summary>
            Create a Kriging interpolator
            </summary>
            <param name="Y">Data values, matrix with measured values at the n data points specified by <paramref name="X"/>. Size [k x n].</param>
            <param name="X">Data points, matrix with sample locations of dimension m in n columns. At least 2 samples must be provided.</param>
            <param name="variogram">[Optional] Variogram function of the euclidian distances. Default: <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.PowerLawVariogram(ILNumerics.InArray{System.Single})"/></param>
            <param name="errors">[Optional] (this paramter is currently ignored)</param>
            <param name="doChecks">[Optional] True: check the distances between points provided in <paramref name="X"/> for too small values (default). False: do not perform these checks (and save some computations).</param>
            <remarks><para>The optional parameter <paramref name="doChecks"/> is used to prevent the kriging interpolator from instability effects caused by disadvantageous positions <paramref name="X"/>. If points in 
            <paramref name="X"/> are too close to each other, the resulting distance matrix (and its inversion later on) might cause singularity problems. Therefore and if <paramref name="doChecks"/> is <c>true</c> 
            checks are automatically made for that and potential redundant values are removed from the data set.</para></remarks>
            <exception cref="T:System.ArgumentException"> is thrown if either of <paramref name="X"/> or <paramref name="Y"/> are null or do not have matching sizes.</exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="errors"/> is not null but also not a vector of lenght <c>X.S[1]</c>.</exception>
            <exception cref="T:System.ArgumentException"> if too few points are provided or all provided points <paramref name="X"/> are too close to each other so that no reliable interpolation can be performed.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
            <summary>
            Apply new data points to the interpolator in order to estimate new values for them.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dim"/>.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para>
            <para>The additional input argument <paramref name="arguments"/> is currently ignored.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.OutArray{System.Single})">
            <summary>
            Compute interpolated values and optionally compute confidence estimates for new data points.
            </summary>
            <param name="X">Data points in columns. X.S[0] must equal <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dim"/>.</param>
            <param name="errors">[Optional] if none-null on entry confidence estimates (error estimates) are computed for the positions in <paramref name="X"/>.</param>
            <returns>Interpolated values for each point (column) provided in X.</returns>
            <remarks><para>If <see cref="P:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dim"/> equals 1 then <paramref name="X"/> is allowed to be a column vector also.</para></remarks>
            <see cref="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.KrigingInterpolatorSingle.Dispose">
            <summary>
            Dispose this object and all resources stored inside it after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.LinearInterpolatorDouble">
            <summary>
            LinearInterpolator class provides 1D linear interpolation.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
             <summary>        
             Creates a linear interpolations object, using specified points <paramref name="X"/> and <paramref name="V"/>
             </summary>
             
             <param name="V">Given values. Vector of length n or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array of length m.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorDouble"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new LinearInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new LinearInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorDouble.Dispose">
            <summary>
            Disposes this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.LinearInterpolatorComplex">
            <summary>
            LinearInterpolator class provides 1D linear interpolation.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex})">
             <summary>        
             Creates a linear interpolations object, using specified points <paramref name="X"/> and <paramref name="V"/>
             </summary>
             
             <param name="V">Given values. Vector of length n or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array of length m.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorDouble"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new LinearInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new LinearInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorComplex.Dispose">
            <summary>
            Disposes this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.LinearInterpolatorFComplex">
            <summary>
            LinearInterpolator class provides 1D linear interpolation.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex})">
             <summary>        
             Creates a linear interpolations object, using specified points <paramref name="X"/> and <paramref name="V"/>
             </summary>
             
             <param name="V">Given values. Vector of length n or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array of length m.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorSingle"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new LinearInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new LinearInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorFComplex.Dispose">
            <summary>
            Disposes this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.LinearInterpolatorSingle">
            <summary>
            LinearInterpolator class provides 1D linear interpolation.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
             <summary>        
             Creates a linear interpolations object, using specified points <paramref name="X"/> and <paramref name="V"/>
             </summary>
             
             <param name="V">Given values. Vector of length n or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array of length m.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorSingle"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.LinearInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new LinearInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">(Ignored)</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new LinearInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.LinearInterpolatorSingle.Dispose">
            <summary>
            Disposes this interpolator object after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.NearestInterpolatorDouble">
            <summary>
            NearestInterpolator class provides 1D interpolation using Nearest Neighbor Interpolation function.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>        
             Creates a Nearest Neighbor interpolation object, using specified points <paramref name="X"/>, <paramref name="V"/> and <paramref name="method"/>(nearest, next or previous)
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., l_(n-1)].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             <param name="method">[Optional] Next, Previous or Nearest neighbor interpolation method. Nearest is default.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorDouble"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <list type="bullet">
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
             is closest to a new query point. This method needs little computing ressources.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
             For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
             This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
             to the ceil() function. If no 'next' sample is available (for extrapolating query points) the sample at the right edge is returned. 
             At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
             </list>
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new NearestInterpolatorDouble(V, X, method:InterpolationMethod.next)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is specified not as nearest, next or previous.</exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new NearestInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorDouble.Dispose">
            <summary>
            Disposes off this interpolator after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.NearestInterpolatorComplex">
            <summary>
            NearestInterpolator class provides 1D interpolation using Nearest Neighbor Interpolation function.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>        
             Creates a Nearest Neighbor interpolation object, using specified points <paramref name="X"/>, <paramref name="V"/> and <paramref name="method"/>(nearest, next or previous)
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., l_(n-1)].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             <param name="method">[Optional] Next, Previous or Nearest neighbor interpolation method. Nearest is default.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorDouble"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <list type="bullet">
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
             is closest to a new query point. This method needs little computing ressources.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
             For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
             This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
             to the ceil() function. If no 'next' sample is available (for extrapolating query points) the sample at the right edge is returned. 
             At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
             </list>
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new NearestInterpolatorDouble(V, X, method:InterpolationMethod.next)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is specified not as nearest, next or previous.</exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new NearestInterpolatorDouble(V, X)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorComplex.Dispose">
            <summary>
            Disposes off this interpolator after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.NearestInterpolatorFComplex">
            <summary>
            NearestInterpolator class provides 1D interpolation using Nearest Neighbor Interpolation function.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>        
             Creates a Nearest Neighbor interpolation object, using specified points <paramref name="X"/>, <paramref name="V"/> and <paramref name="method"/>(nearest, next or previous)
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., l_(n-1)].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             <param name="method">[Optional] Next, Previous or Nearest neighbor interpolation method. Nearest is default.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorSingle"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <list type="bullet">
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
             is closest to a new query point. This method needs little computing ressources.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
             For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
             This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
             to the ceil() function. If no 'next' sample is available (for extrapolating query points) the sample at the right edge is returned. 
             At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
             </list>
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new NearestInterpolatorSingle(V, X, method:InterpolationMethod.next)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is specified not as nearest, next or previous.</exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new NearestInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorFComplex.Dispose">
            <summary>
            Disposes off this interpolator after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.NearestInterpolatorSingle">
            <summary>
            NearestInterpolator class provides 1D interpolation using Nearest Neighbor Interpolation function.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.Toolboxes.InterpolationMethod)">
             <summary>        
             Creates a Nearest Neighbor interpolation object, using specified points <paramref name="X"/>, <paramref name="V"/> and <paramref name="method"/>(nearest, next or previous)
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., l_(n-1)].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>        
             <param name="method">[Optional] Next, Previous or Nearest neighbor interpolation method. Nearest is default.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorSingle"/> prepares a 1-dimensional, linear interpolation object, 
             for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.NearestInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <list type="bullet">
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> - Nearest neighbor interpolation returns the corresponding sample point from <paramref name="V"/> which 
             is closest to a new query point. This method needs little computing ressources.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/> - returns the sample point left from a new query point; corresponds to the floor() function. 
             For query points outside of the specified domain the nearest available sample point is returned. At least 2 samples are required in each dimension. 
             This function requires little resources and performs at about the same speed as <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/>.</item>
             <item><see cref="F:ILNumerics.Toolboxes.InterpolationMethod.next"/> - returns the sample point from <paramref name="V"/> which is right from a new query point; corresponds 
             to the ceil() function. If no 'next' sample is available (for extrapolating query points) the sample at the right edge is returned. 
             At least 2 samples are required in each dimension. This function needs little resources and performs with about the same speed as 
             <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.nearest"/> and <see cref="F:ILNumerics.Toolboxes.InterpolationMethod.previous"/>.</item>
             </list>
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S.NumberOfElements / V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b></para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object
             using (var interp = new NearestInterpolatorSingle(V, X, method:InterpolationMethod.next)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If arguments length <paramref name="X"/> or <paramref name="V"/> less than 2 elements</exception>
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>        
             <exception cref="T:System.ArgumentException">If argument <paramref name="method"/> is specified not as nearest, next or previous.</exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             method returns linear interpolated values at specific query points <paramref name="X"/>.
             </summary>
             
             <param name="X">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             
             <remarks>
             <para><paramref name="X"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="X"/> is 
             not taken into account. If <paramref name="X"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="X"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new NearestInterpolatorSingle(V, X)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.NearestInterpolatorSingle.Dispose">
            <summary>
            Disposes off this interpolator after use.
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.PolynomialInterpolatorDouble">
            <summary>
            The PolynomialInterpolator[...] classes provide 1D interpolation using polynomial interpolation of varying orders.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double},System.Int32)">
             <summary>
             Creates a polynomial interpolations object of <paramref name="order"/>, using specified points <paramref name="X"/> and <paramref name="V"/>        
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
             <param name="order">[Optional] Defines the order of the Lagrange polynom used for interpolation. Default: (0) method <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/> returns <paramref name="V"/>.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorDouble"/> prepares a 1-dimensional, Lagrange-Polynomial interpolation object of 
             order = <paramref name="order"/>, for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b>.</para>
             
             <para>Values of <paramref name="order"/> larger than 7 are not recommeded to prevent from loss of precision.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorDouble(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>
             <exception cref="T:System.ArgumentException">If <paramref name="order"/> value is less than 0 or more than length of <paramref name="X"/></exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             Method returns interpolated values using polynomial function at specific query points <paramref name="Xn"/>.
             </summary>
             
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="Xn"/> is 
             not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<double> X = linspace<double>(-pi, pi, 10);
             Array<double> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorDouble(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 double val1 = (double)interp.Apply(0.024);
                 double val2 = (double)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<double> valRange = interp.Apply(linspace<double>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<double> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<double> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorDouble.Dispose">
            <summary>
            Disposes off this interpolator object after use. 
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.PolynomialInterpolatorComplex">
            <summary>
            The PolynomialInterpolator[...] classes provide 1D interpolation using polynomial interpolation of varying orders.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},System.Nullable{ILNumerics.complex},System.Int32)">
             <summary>
             Creates a polynomial interpolations object of <paramref name="order"/>, using specified points <paramref name="X"/> and <paramref name="V"/>        
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
             <param name="order">[Optional] Defines the order of the Lagrange polynom used for interpolation. Default: (0) method <see cref="!:Apply(InArray&lt;complex&gt;, InCell)"/> returns <paramref name="V"/>.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorDouble"/> prepares a 1-dimensional, Lagrange-Polynomial interpolation object of 
             order = <paramref name="order"/>, for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorDouble"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b>.</para>
             
             <para>Values of <paramref name="order"/> larger than 7 are not recommeded to prevent from loss of precision.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorDouble(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>
             <exception cref="T:System.ArgumentException">If <paramref name="order"/> value is less than 0 or more than length of <paramref name="X"/></exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
             <summary>        
             Method returns interpolated values using polynomial function at specific query points <paramref name="Xn"/>.
             </summary>
             
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="Xn"/> is 
             not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<complex> X = linspace<complex>(-pi, pi, 10);
             Array<complex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorDouble(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 complex val1 = (complex)interp.Apply(0.024);
                 complex val2 = (complex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<complex> valRange = interp.Apply(linspace<complex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<complex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<complex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorComplex.Dispose">
            <summary>
            Disposes off this interpolator object after use. 
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex">
            <summary>
            The PolynomialInterpolator[...] classes provide 1D interpolation using polynomial interpolation of varying orders.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},System.Nullable{ILNumerics.fcomplex},System.Int32)">
             <summary>
             Creates a polynomial interpolations object of <paramref name="order"/>, using specified points <paramref name="X"/> and <paramref name="V"/>        
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
             <param name="order">[Optional] Defines the order of the Lagrange polynom used for interpolation. Default: (0) method <see cref="!:Apply(InArray&lt;fcomplex&gt;, InCell)"/> returns <paramref name="V"/>.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorSingle"/> prepares a 1-dimensional, Lagrange-Polynomial interpolation object of 
             order = <paramref name="order"/>, for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b>.</para>
             
             <para>Values of <paramref name="order"/> larger than 7 are not recommeded to prevent from loss of precision.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorSingle(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>
             <exception cref="T:System.ArgumentException">If <paramref name="order"/> value is less than 0 or more than length of <paramref name="X"/></exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             Method returns interpolated values using polynomial function at specific query points <paramref name="Xn"/>.
             </summary>
             
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="Xn"/> is 
             not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<fcomplex> X = linspace<fcomplex>(-pi, pi, 10);
             Array<fcomplex> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorSingle(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 fcomplex val1 = (fcomplex)interp.Apply(0.024);
                 fcomplex val2 = (fcomplex)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<fcomplex> valRange = interp.Apply(linspace<fcomplex>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<fcomplex> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<fcomplex> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorFComplex.Dispose">
            <summary>
            Disposes off this interpolator object after use. 
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.PolynomialInterpolatorSingle">
            <summary>
            The PolynomialInterpolator[...] classes provide 1D interpolation using polynomial interpolation of varying orders.
            </summary>      
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single},System.Int32)">
             <summary>
             Creates a polynomial interpolations object of <paramref name="order"/>, using specified points <paramref name="X"/> and <paramref name="V"/>        
             </summary>
             
             <param name="V">Given values. Vector of length m or n-dimensional array of size [m, l1, l2, ..., ln].</param>
             <param name="X">Strictly monotonically increasing x coordinates. Vector or n-dimensional array with m elements.</param>
             <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
             <param name="order">[Optional] Defines the order of the Lagrange polynom used for interpolation. Default: (0) method <see cref="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/> returns <paramref name="V"/>.</param>
             
             <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
             <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorSingle"/> prepares a 1-dimensional, Lagrange-Polynomial interpolation object of 
             order = <paramref name="order"/>, for the given set of <b>m</b> measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
             been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.PolynomialInterpolatorSingle"/> 
             inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
             <para>Once created object could be reused to get interpolated values using Apply() method.</para>
             
             <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
             positions as determined by <paramref name="X"/>. It performs interpolation through the columns of sample values <paramref name="V"/>. 
             Each element requested in <c>Apply(Xn)</c> method will be interpolated for each column of <paramref name="V"/>. In this case <b>m</b> becomes: V.S[0].</para>
             
             <para>If <paramref name="V"/> is defined as vector row or column with size <b>m</b>, number of elements <paramref name="X"/> must be <b>m</b>.</para>
             
             <para>Values of <paramref name="order"/> larger than 7 are not recommeded to prevent from loss of precision.</para>
             </remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorSingle(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
                    
             <exception cref="T:System.ArgumentException">If argument <paramref name="X"/> not ascending and distinct</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> are specified not as vector or array.</exception>
             <exception cref="T:System.ArgumentException">If <paramref name="order"/> value is less than 0 or more than length of <paramref name="X"/></exception>
             <exception cref="T:System.ArgumentNullException">If any of input parameters are NULL</exception>
             <exception cref="T:System.ArgumentException">If arguments <paramref name="X"/> or <paramref name="V"/> have different size.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
             <summary>        
             Method returns interpolated values using polynomial function at specific query points <paramref name="Xn"/>.
             </summary>
             
             <param name="Xn">Query points, specified as a scalar, vector or n-dim array of real numbers.</param>
             <param name="arguments">Currently not used</param>
             <returns>Interpolated data, see remarks for size details.</returns>
             <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the trained object state. The shape of <paramref name="Xn"/> is 
             not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
             <para>Interpolation values are computed from the original values V used to train this interpolator objects. 
             The array returned will have the same shape as V, 
             except the working dimension of V is replaced with n interpolated values, n = <paramref name="Xn"/>.S.NumberOfElements. The 'working dimension' of 
             V is 1 if V is a row vector, 0 otherwise.</para></remarks>
             
             <example>
             <para>
             <code>
             <![CDATA[
             
             // Define some sample points as a function: f(x) = sin(x);
             Array<float> X = linspace<float>(-pi, pi, 10);
             Array<float> V = sin(X);
            
             // Create Interpolator Object order 5
             using (var interp = new PolynomialInterpolatorSingle(V, X, order:5)) 
             { 
                 // Get some random scalar values
                 float val1 = (float)interp.Apply(0.024);
                 float val2 = (float)interp.Apply(-0.21);
                 
                 // Get 10 linear spaced values defined on range (-0.5, 1.25)
                 Array<float> valRange = interp.Apply(linspace<float>(-0.5, 1.25, 10));
                 
                 // Get 30 interpolated values using Xn query points defined as array[3 x 2 x 5]
                 Array<float> Xn = counter(0.0, 0.1, 3, 2, 5);
                 Array<float> Vn = interp.Apply(Xn);
             }  
             ]]>
             </code>
             </para>
             </example>
             
             <exception cref="T:System.ArgumentNullException">If an input parameters are NULL</exception>
             <exception cref="T:System.InvalidOperationException">If Interpolation object has been disposed before Apply() calls</exception>
        </member>
        <member name="M:ILNumerics.Toolboxes.PolynomialInterpolatorSingle.Dispose">
            <summary>
            Disposes off this interpolator object after use. 
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes.SplineInterpolatorDouble">
            <summary>
            Spline interpolation object 
            </summary>
            <remarks>This class creates an interpolation object for efficient cubic spline interpolation of arbitrary 1 dim data.</remarks>    
        </member>
        <member name="P:ILNumerics.Toolboxes.SplineInterpolatorDouble.X">
            <summary>
            Return the original positions vector X used to create this interpolator object; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double})">
            <summary>
            Create cubic spline interpolator object from known values.
            </summary>
            <param name="V">Known values. Vector of length n or matrix of size [m x n].</param>
            <param name="X">Strictly monotonically increasing x coordinates. Vector of length n.</param>
            <param name="lowerBoundDerivative">[Optional] Lower boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="F:System.Double.PositiveInfinity"/>), natural (<see cref="F:System.Double.NaN"/>).</param>
            <param name="upperBoundDerivative">[Optional] Upper boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="F:System.Double.PositiveInfinity"/>), natural (<see cref="F:System.Double.NaN"/>).</param>
            <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
            <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
            <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> prepares a 1-dimensional, single spline interpolation object 
            for the given set of n measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
            been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> 
            inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
            <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
            positions as determined by <paramref name="X"/>. Each element requested in <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/> later will be interpolated for each column of <paramref name="V"/>. In this case
            m becomes: V.S.NumberOfElements / V.S[0].</para>
            <para>The parameters <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> determine the first derivatives at the lower and 
            upper end of the spline interpolations for each column of <paramref name="V"/> respectively. If a vector is provided its length must match m, the number of sets provided in <paramref name="V"/>. 
            Possible values for elements in <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> are: <list type="bullet">
            <item><see cref="F:System.Double.NaN"/>: 'natural spline': the first derivative depends on the slope of the neighboring pieces. The second derivative will be zero.</item>
            <item><see cref="F:System.Double.PositiveInfinity"/>: 'not-a-knot spline' (default): based on the existing three points next to the boundary a cubic polynomial is used to construct a new 
            virtual point outside of the specified domain. The derivative at the end points is than computed from it. This corresponds to 'leaving' out one knot / value, hence the name.</item>
            <item>Other numerical values are considered as the <i>first</i> derivative for the corresponding sample set in <paramref name="V"/>.</item>
            </list></para>
            <para>Providing a scalar array for either one of <paramref name="upperBoundDerivative"/> and/or <paramref name="lowerBoundDerivative"/> will cause 
            the corresponding derivatives of all sample sets to behave according to the above list. Null (the default) or an empty array leads to 'not-a-knot' splines for all sample sets.</para>
            <para>Spline interpolation requires at least 4 values in the working dimension of <paramref name="V"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if either <paramref name="X"/> or <paramref name="V"/> are null on entry.</exception>
            <exception cref="T:System.ArgumentException"> on any invalid argument.</exception>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double})"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Double},System.Nullable{System.Double},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
            <summary>        
            Interpolate values at new query points, based on the same set of data used for creating this interpolator.
            </summary>
            <param name="Xn">Query points, specified as a vector or array of real numbers.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated data, see remarks for size details.</returns>
            <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the original set of data as provided to the 
            <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double})">constructor</see>. 
            The shape of <paramref name="Xn"/> is not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
            <para>The array returned will have the same shape as V, except the working dimension of V is replaced with n interpolated values, <c>n = <paramref name="Xn"/>.S.NumberOfElements</c>. 
            The 'working dimension' of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
            <example>
            <para>
            <code>
            <![CDATA[
            using (var interp = new PolynomialInterpolator(x, y)) 
            { 
                Array<double> yq = interp.Apply(xq);
            }  
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If an input parameter is <c>null</c>.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.GetCoefficients">
            <summary>
            Retrieve the spline coefficients of this interpolator object. 
            </summary>
            <returns>Spline coefficients as matrix.</returns>
            <remarks>The coefficients for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> store the original values the object was created for as well as 
            the derivatives of order 1..3. These coefficients are needed for efficient application of the spline interpolation at arbitrary points.
            <para><see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)"/> uses the coefficients for exactly this purpose. 
            Furthermore, <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.GetCoefficients"/> is utilized for n-dimensional spline interpolation of scattered points on gridded data 
            as performed by <see cref="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Double},ILNumerics.InCell,ILNumerics.InArray{System.Double})"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.Dispose">
            <summary>
            Dispose this interpolator object. 
            </summary>
            <remarks>It is recommended to use any object implementing <see cref="T:System.IDisposable"/> in the context of a 'using' directive (C#, Using in VB).
            When doing so, the explicit call of <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.Dispose"/> is mostly not needed.</remarks>
        </member>
        <member name="T:ILNumerics.Toolboxes.SplineInterpolatorComplex">
            <summary>
            Spline interpolation object 
            </summary>
            <remarks>This class creates an interpolation object for efficient cubic spline interpolation of arbitrary 1 dim data.</remarks>    
        </member>
        <member name="P:ILNumerics.Toolboxes.SplineInterpolatorComplex.X">
            <summary>
            Return the original positions vector X used to create this interpolator object; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.#ctor(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{System.Double},ILNumerics.InArray{ILNumerics.complex},ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex})">
            <summary>
            Create cubic spline interpolator object from known values.
            </summary>
            <param name="V">Known values. Vector of length n or matrix of size [m x n].</param>
            <param name="X">Strictly monotonically increasing x coordinates. Vector of length n.</param>
            <param name="lowerBoundDerivative">[Optional] Lower boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="P:ILNumerics.complex.PositiveInfinity"/>), natural (<see cref="P:ILNumerics.complex.NaN"/>).</param>
            <param name="upperBoundDerivative">[Optional] Upper boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="P:ILNumerics.complex.PositiveInfinity"/>), natural (<see cref="P:ILNumerics.complex.NaN"/>).</param>
            <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
            <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
            <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> prepares a 1-dimensional, single spline interpolation object 
            for the given set of n measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
            been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> 
            inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
            <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
            positions as determined by <paramref name="X"/>. Each element requested in <see cref="!:SplineInterpolatorDouble.Apply(InArray&lt;complex&gt;, InCell)"/> later will be interpolated for each column of <paramref name="V"/>. In this case
            m becomes: V.S.NumberOfElements / V.S[0].</para>
            <para>The parameters <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> determine the first derivatives at the lower and 
            upper end of the spline interpolations for each column of <paramref name="V"/> respectively. If a vector is provided its length must match m, the number of sets provided in <paramref name="V"/>. 
            Possible values for elements in <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> are: <list type="bullet">
            <item><see cref="P:ILNumerics.complex.NaN"/>: 'natural spline': the first derivative depends on the slope of the neighboring pieces. The second derivative will be zero.</item>
            <item><see cref="P:ILNumerics.complex.PositiveInfinity"/>: 'not-a-knot spline' (default): based on the existing three points next to the boundary a cubic polynomial is used to construct a new 
            virtual point outside of the specified domain. The derivative at the end points is than computed from it. This corresponds to 'leaving' out one knot / value, hence the name.</item>
            <item>Other numerical values are considered as the <i>first</i> derivative for the corresponding sample set in <paramref name="V"/>.</item>
            </list></para>
            <para>Providing a scalar array for either one of <paramref name="upperBoundDerivative"/> and/or <paramref name="lowerBoundDerivative"/> will cause 
            the corresponding derivatives of all sample sets to behave according to the above list. Null (the default) or an empty array leads to 'not-a-knot' splines for all sample sets.</para>
            <para>Spline interpolation requires at least 4 values in the working dimension of <paramref name="V"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if either <paramref name="X"/> or <paramref name="V"/> are null on entry.</exception>
            <exception cref="T:System.ArgumentException"> on any invalid argument.</exception>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.spline(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.interp1(InArray&lt;complex&gt;, complex?, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.interp2(InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, InArray&lt;complex&gt;, int, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.complex},System.Nullable{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.Apply(ILNumerics.InArray{System.Double},ILNumerics.InCell)">
            <summary>        
            Interpolate values at new query points, based on the same set of data used for creating this interpolator.
            </summary>
            <param name="Xn">Query points, specified as a vector or array of real numbers.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated data, see remarks for size details.</returns>
            <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the original set of data as provided to the 
            <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorDouble.#ctor(ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},ILNumerics.InArray{System.Double},System.Nullable{System.Double})">constructor</see>. 
            The shape of <paramref name="Xn"/> is not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
            <para>The array returned will have the same shape as V, except the working dimension of V is replaced with n interpolated values, <c>n = <paramref name="Xn"/>.S.NumberOfElements</c>. 
            The 'working dimension' of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
            <example>
            <para>
            <code>
            <![CDATA[
            using (var interp = new PolynomialInterpolator(x, y)) 
            { 
                Array<complex> yq = interp.Apply(xq);
            }  
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If an input parameter is <c>null</c>.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.GetCoefficients">
            <summary>
            Retrieve the spline coefficients of this interpolator object. 
            </summary>
            <returns>Spline coefficients as matrix.</returns>
            <remarks>The coefficients for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorDouble"/> store the original values the object was created for as well as 
            the derivatives of order 1..3. These coefficients are needed for efficient application of the spline interpolation at arbitrary points.
            <para><see cref="!:SplineInterpolatorDouble.Apply(InArray&lt;complex&gt;, InCell)"/> uses the coefficients for exactly this purpose. 
            Furthermore, <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.GetCoefficients"/> is utilized for n-dimensional spline interpolation of scattered points on gridded data 
            as performed by <see cref="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.complex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.complex})"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.Dispose">
            <summary>
            Dispose this interpolator object. 
            </summary>
            <remarks>It is recommended to use any object implementing <see cref="T:System.IDisposable"/> in the context of a 'using' directive (C#, Using in VB).
            When doing so, the explicit call of <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorComplex.Dispose"/> is mostly not needed.</remarks>
        </member>
        <member name="T:ILNumerics.Toolboxes.SplineInterpolatorFComplex">
            <summary>
            Spline interpolation object 
            </summary>
            <remarks>This class creates an interpolation object for efficient cubic spline interpolation of arbitrary 1 dim data.</remarks>    
        </member>
        <member name="P:ILNumerics.Toolboxes.SplineInterpolatorFComplex.X">
            <summary>
            Return the original positions vector X used to create this interpolator object; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.#ctor(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{System.Single},ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex})">
            <summary>
            Create cubic spline interpolator object from known values.
            </summary>
            <param name="V">Known values. Vector of length n or matrix of size [m x n].</param>
            <param name="X">Strictly monotonically increasing x coordinates. Vector of length n.</param>
            <param name="lowerBoundDerivative">[Optional] Lower boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="P:ILNumerics.fcomplex.PositiveInfinity"/>), natural (<see cref="P:ILNumerics.fcomplex.NaN"/>).</param>
            <param name="upperBoundDerivative">[Optional] Upper boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="P:ILNumerics.fcomplex.PositiveInfinity"/>), natural (<see cref="P:ILNumerics.fcomplex.NaN"/>).</param>
            <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
            <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
            <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> prepares a 1-dimensional, single spline interpolation object 
            for the given set of n measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
            been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> 
            inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
            <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
            positions as determined by <paramref name="X"/>. Each element requested in <see cref="!:SplineInterpolatorSingle.Apply(InArray&lt;fcomplex&gt;, InCell)"/> later will be interpolated for each column of <paramref name="V"/>. In this case
            m becomes: V.S.NumberOfElements / V.S[0].</para>
            <para>The parameters <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> determine the first derivatives at the lower and 
            upper end of the spline interpolations for each column of <paramref name="V"/> respectively. If a vector is provided its length must match m, the number of sets provided in <paramref name="V"/>. 
            Possible values for elements in <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> are: <list type="bullet">
            <item><see cref="P:ILNumerics.fcomplex.NaN"/>: 'natural spline': the first derivative depends on the slope of the neighboring pieces. The second derivative will be zero.</item>
            <item><see cref="P:ILNumerics.fcomplex.PositiveInfinity"/>: 'not-a-knot spline' (default): based on the existing three points next to the boundary a cubic polynomial is used to construct a new 
            virtual point outside of the specified domain. The derivative at the end points is than computed from it. This corresponds to 'leaving' out one knot / value, hence the name.</item>
            <item>Other numerical values are considered as the <i>first</i> derivative for the corresponding sample set in <paramref name="V"/>.</item>
            </list></para>
            <para>Providing a scalar array for either one of <paramref name="upperBoundDerivative"/> and/or <paramref name="lowerBoundDerivative"/> will cause 
            the corresponding derivatives of all sample sets to behave according to the above list. Null (the default) or an empty array leads to 'not-a-knot' splines for all sample sets.</para>
            <para>Spline interpolation requires at least 4 values in the working dimension of <paramref name="V"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if either <paramref name="X"/> or <paramref name="V"/> are null on entry.</exception>
            <exception cref="T:System.ArgumentException"> on any invalid argument.</exception>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.spline(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.interp1(InArray&lt;fcomplex&gt;, fcomplex?, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            <seealso cref="!:ILNumerics.Toolboxes.Interpolation.interp2(InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, InArray&lt;fcomplex&gt;, int, InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{ILNumerics.fcomplex},System.Nullable{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
            <summary>        
            Interpolate values at new query points, based on the same set of data used for creating this interpolator.
            </summary>
            <param name="Xn">Query points, specified as a vector or array of real numbers.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated data, see remarks for size details.</returns>
            <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the original set of data as provided to the 
            <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single})">constructor</see>. 
            The shape of <paramref name="Xn"/> is not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
            <para>The array returned will have the same shape as V, except the working dimension of V is replaced with n interpolated values, <c>n = <paramref name="Xn"/>.S.NumberOfElements</c>. 
            The 'working dimension' of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
            <example>
            <para>
            <code>
            <![CDATA[
            using (var interp = new PolynomialInterpolator(x, y)) 
            { 
                Array<fcomplex> yq = interp.Apply(xq);
            }  
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If an input parameter is <c>null</c>.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.GetCoefficients">
            <summary>
            Retrieve the spline coefficients of this interpolator object. 
            </summary>
            <returns>Spline coefficients as matrix.</returns>
            <remarks>The coefficients for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> store the original values the object was created for as well as 
            the derivatives of order 1..3. These coefficients are needed for efficient application of the spline interpolation at arbitrary points.
            <para><see cref="!:SplineInterpolatorSingle.Apply(InArray&lt;fcomplex&gt;, InCell)"/> uses the coefficients for exactly this purpose. 
            Furthermore, <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.GetCoefficients"/> is utilized for n-dimensional spline interpolation of scattered points on gridded data 
            as performed by <see cref="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{ILNumerics.fcomplex},ILNumerics.InCell,ILNumerics.InArray{ILNumerics.fcomplex})"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.Dispose">
            <summary>
            Dispose this interpolator object. 
            </summary>
            <remarks>It is recommended to use any object implementing <see cref="T:System.IDisposable"/> in the context of a 'using' directive (C#, Using in VB).
            When doing so, the explicit call of <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorFComplex.Dispose"/> is mostly not needed.</remarks>
        </member>
        <member name="T:ILNumerics.Toolboxes.SplineInterpolatorSingle">
            <summary>
            Spline interpolation object 
            </summary>
            <remarks>This class creates an interpolation object for efficient cubic spline interpolation of arbitrary 1 dim data.</remarks>    
        </member>
        <member name="P:ILNumerics.Toolboxes.SplineInterpolatorSingle.X">
            <summary>
            Return the original positions vector X used to create this interpolator object; 
            </summary>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single})">
            <summary>
            Create cubic spline interpolator object from known values.
            </summary>
            <param name="V">Known values. Vector of length n or matrix of size [m x n].</param>
            <param name="X">Strictly monotonically increasing x coordinates. Vector of length n.</param>
            <param name="lowerBoundDerivative">[Optional] Lower boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="F:System.Single.PositiveInfinity"/>), natural (<see cref="F:System.Single.NaN"/>).</param>
            <param name="upperBoundDerivative">[Optional] Upper boundary 1st derivative(s). Options: given value(s), not-a-knot (<c>null</c> (default) or <see cref="F:System.Single.PositiveInfinity"/>), natural (<see cref="F:System.Single.NaN"/>).</param>
            <param name="outOfRangeValues">[Optional] Value to be assigned to all interpolation results outside of the domain specified by <paramref name="X"/>. Default: (null) extrapolate.</param>
            <remarks>This object should be used in a <c>using</c> block in order to clean up its resources after use.
            <para>For an input vector <paramref name="V"/>, <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> prepares a 1-dimensional, single spline interpolation object 
            for the given set of n measured values. Subsequently, interpolated values can be derived by help of this object efficiently. After all values have 
            been acquired, the object should be released in order to free its resources. Commonly, in .NET, the utiliziation of <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> 
            inside of a <see href="https://msdn.microsoft.com/en-us/library/vstudio/sf0df423%28v=vs.140%29.aspx">using</see> directive is recommended.</para>
            <para>If <paramref name="V"/> is provided as a matrix or a n-dim array, the columns of <paramref name="V"/> are considered as m individual sets of measurements, all at the same 
            positions as determined by <paramref name="X"/>. Each element requested in <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/> later will be interpolated for each column of <paramref name="V"/>. In this case
            m becomes: V.S.NumberOfElements / V.S[0].</para>
            <para>The parameters <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> determine the first derivatives at the lower and 
            upper end of the spline interpolations for each column of <paramref name="V"/> respectively. If a vector is provided its length must match m, the number of sets provided in <paramref name="V"/>. 
            Possible values for elements in <paramref name="upperBoundDerivative"/> and <paramref name="lowerBoundDerivative"/> are: <list type="bullet">
            <item><see cref="F:System.Single.NaN"/>: 'natural spline': the first derivative depends on the slope of the neighboring pieces. The second derivative will be zero.</item>
            <item><see cref="F:System.Single.PositiveInfinity"/>: 'not-a-knot spline' (default): based on the existing three points next to the boundary a cubic polynomial is used to construct a new 
            virtual point outside of the specified domain. The derivative at the end points is than computed from it. This corresponds to 'leaving' out one knot / value, hence the name.</item>
            <item>Other numerical values are considered as the <i>first</i> derivative for the corresponding sample set in <paramref name="V"/>.</item>
            </list></para>
            <para>Providing a scalar array for either one of <paramref name="upperBoundDerivative"/> and/or <paramref name="lowerBoundDerivative"/> will cause 
            the corresponding derivatives of all sample sets to behave according to the above list. Null (the default) or an empty array leads to 'not-a-knot' splines for all sample sets.</para>
            <para>Spline interpolation requires at least 4 values in the working dimension of <paramref name="V"/>.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException"> if either <paramref name="X"/> or <paramref name="V"/> are null on entry.</exception>
            <exception cref="T:System.ArgumentException"> on any invalid argument.</exception>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.spline(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single})"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.splinen(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InCell)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interp1(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interp2(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Int32,ILNumerics.Toolboxes.InterpolationMethod)"/>
            <seealso cref="M:ILNumerics.Toolboxes.Interpolation.interpn(ILNumerics.InArray{System.Single},System.Nullable{System.Single},ILNumerics.InCell,ILNumerics.InCell,ILNumerics.Toolboxes.InterpolationMethod)"/>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)">
            <summary>        
            Interpolate values at new query points, based on the same set of data used for creating this interpolator.
            </summary>
            <param name="Xn">Query points, specified as a vector or array of real numbers.</param>
            <param name="arguments">(ignored)</param>
            <returns>Interpolated data, see remarks for size details.</returns>
            <remarks><para><paramref name="Xn"/> defines new positions for the interpolation based on the original set of data as provided to the 
            <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.#ctor(ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},ILNumerics.InArray{System.Single},System.Nullable{System.Single})">constructor</see>. 
            The shape of <paramref name="Xn"/> is not taken into account. If <paramref name="Xn"/> is not a vector, its values are read in sequential order.</para>
            <para>The array returned will have the same shape as V, except the working dimension of V is replaced with n interpolated values, <c>n = <paramref name="Xn"/>.S.NumberOfElements</c>. 
            The 'working dimension' of V is 1 if V is a row vector, 0 otherwise.</para></remarks>
            <example>
            <para>
            <code>
            <![CDATA[
            using (var interp = new PolynomialInterpolator(x, y)) 
            { 
                Array<float> yq = interp.Apply(xq);
            }  
            ]]>
            </code>
            </para>
            </example>
            <exception cref="T:System.ArgumentNullException">If an input parameter is <c>null</c>.</exception>        
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.GetCoefficients">
            <summary>
            Retrieve the spline coefficients of this interpolator object. 
            </summary>
            <returns>Spline coefficients as matrix.</returns>
            <remarks>The coefficients for <see cref="T:ILNumerics.Toolboxes.SplineInterpolatorSingle"/> store the original values the object was created for as well as 
            the derivatives of order 1..3. These coefficients are needed for efficient application of the spline interpolation at arbitrary points.
            <para><see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.Apply(ILNumerics.InArray{System.Single},ILNumerics.InCell)"/> uses the coefficients for exactly this purpose. 
            Furthermore, <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.GetCoefficients"/> is utilized for n-dimensional spline interpolation of scattered points on gridded data 
            as performed by <see cref="M:ILNumerics.Toolboxes.Interpolation.splinens(ILNumerics.InArray{System.Single},ILNumerics.InCell,ILNumerics.InArray{System.Single})"/>.</para></remarks>
        </member>
        <member name="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.Dispose">
            <summary>
            Dispose this interpolator object. 
            </summary>
            <remarks>It is recommended to use any object implementing <see cref="T:System.IDisposable"/> in the context of a 'using' directive (C#, Using in VB).
            When doing so, the explicit call of <see cref="M:ILNumerics.Toolboxes.SplineInterpolatorSingle.Dispose"/> is mostly not needed.</remarks>
        </member>
    </members>
</doc>
